/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/engine.io";
exports.ids = ["vendor-chunks/engine.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ exports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsR0FFdEI7O0NBRUMsR0FFREEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxZQUFZLEdBQUdFO0FBQ2ZGLFlBQVksR0FBR0c7QUFDZkgsaUJBQWlCLEdBQUdJO0FBQ3BCSixlQUFlLEdBQUdNO0FBQ2xCTixlQUFlLEdBQUcsQ0FBQztJQUNsQixJQUFJUSxTQUFTO0lBRWIsT0FBTztRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNaQSxTQUFTO1lBQ1RDLFFBQVFDLElBQUksQ0FBQztRQUNkO0lBQ0Q7QUFDRDtBQUVBOztDQUVDLEdBRURWLGNBQWMsR0FBRztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNBO0FBRUQ7Ozs7OztDQU1DLEdBRUQsc0NBQXNDO0FBQ3RDLFNBQVNJO0lBQ1IsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUFnSCxFQUFFLEVBRXJIO0lBRUQsb0RBQW9EO0lBQ3BELElBQUksT0FBT1ksY0FBYyxlQUFlQSxVQUFVQyxTQUFTLElB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RDtRQUMzRCxPQUFPNEM7SUFDUixFQUFFLE9BQU9MLE9BQU87SUFDZixVQUFVO0lBQ1YsMENBQTBDO0lBQzNDO0FBQ0Q7QUFFQWQsT0FBTy9CLE9BQU8sR0FBR21ELG1CQUFPQSxDQUFDLG1GQUFZbkQ7QUFFckMsTUFBTSxFQUFDb0QsVUFBVSxFQUFDLEdBQUdyQixPQUFPL0IsT0FBTztBQUVuQzs7Q0FFQyxHQUVEb0QsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz81Y2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwibG9jYWxzdG9yYWdlIiwiZGVzdHJveSIsIndhcm5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiY29sb3JzIiwid2luZG93IiwicHJvY2VzcyIsInR5cGUiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwibSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCJhcmdzIiwibmFtZXNwYWNlIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsInJlcGxhY2UiLCJsb2ciLCJkZWJ1ZyIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsInJlcXVpcmUiLCJmb3JtYXR0ZXJzIiwiaiIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQyxHQUVELFNBQVNBLE1BQU1DLEdBQUc7SUFDakJDLFlBQVlDLEtBQUssR0FBR0Q7SUFDcEJBLFlBQVlFLE9BQU8sR0FBR0Y7SUFDdEJBLFlBQVlHLE1BQU0sR0FBR0E7SUFDckJILFlBQVlJLE9BQU8sR0FBR0E7SUFDdEJKLFlBQVlLLE1BQU0sR0FBR0E7SUFDckJMLFlBQVlNLE9BQU8sR0FBR0E7SUFDdEJOLFlBQVlPLFFBQVEsR0FBR0MsbUJBQU9BLENBQUM7SUFDL0JSLFlBQVlTLE9BQU8sR0FBR0E7SUFFdEJDLE9BQU9DLElBQUksQ0FBQ1osS0FBS2EsT0FBTyxDQUFDQyxDQUFBQTtRQUN4QmIsV0FBVyxDQUFDYSxJQUFJLEdBQUdkLEdBQUcsQ0FBQ2MsSUFBSTtJQUM1QjtJQUVBOztDQUVBLEdBRUFiLFlBQVljLEtBQUssR0FBRyxFQUFFO0lBQ3RCZCxZQUFZZSxLQUFLLEdBQUcsRUFBRTtJQUV0Qjs7OztDQUlBLEdBQ0FmLFlBQVlnQixVQUFVLEdBQUcsQ0FBQztJQUUxQjs7Ozs7Q0FLQSxHQUNBLFNBQVNDLFlBQVlDLFNBQVM7UUFDN0IsSUFBSUMsT0FBTztRQUVYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRyxNQUFNLEVBQUVELElBQUs7WUFDMUNELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVSSxVQUFVLENBQUNGO1lBQ25ERCxRQUFRLEdBQUcsMkJBQTJCO1FBQ3ZDO1FBRUEsT0FBT25CLFlBQVl1QixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ04sUUFBUW5CLFlBQVl1QixNQUFNLENBQUNGLE1BQU0sQ0FBQztJQUN0RTtJQUNBckIsWUFBWWlCLFdBQVcsR0FBR0E7SUFFMUI7Ozs7OztDQU1BLEdBQ0EsU0FBU2pCLFlBQVlrQixTQUFTO1FBQzdCLElBQUlRO1FB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QU1sRSxZQUFZZSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSThDLEtBQUs5QyxJQUFLO1lBQ3pELElBQUlwQixZQUFZZSxLQUFLLENBQUNLLEVBQUUsQ0FBQ3NELElBQUksQ0FBQ0QsT0FBTztnQkFDcEMsT0FBTztZQUNSO1FBQ0Q7UUFFQSxJQUFLckQsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVljLEtBQUssQ0FBQ08sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVljLEtBQUssQ0FBQ00sRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLE9BQU87SUFDUjtJQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNGLFlBQVlJLE1BQU07UUFDMUIsT0FBT0EsT0FBT0MsUUFBUSxHQUNwQkMsU0FBUyxDQUFDLEdBQUdGLE9BQU9DLFFBQVEsR0FBR3ZELE1BQU0sR0FBRyxHQUN4Q21CLE9BQU8sQ0FBQyxXQUFXO0lBQ3RCO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU3JDLE9BQU95QyxHQUFHO1FBQ2xCLElBQUlBLGVBQWVrQyxPQUFPO1lBQ3pCLE9BQU9sQyxJQUFJbUMsS0FBSyxJQUFJbkMsSUFBSW9DLE9BQU87UUFDaEM7UUFDQSxPQUFPcEM7SUFDUjtJQUVBOzs7Q0FHQSxHQUNBLFNBQVNuQztRQUNSd0UsUUFBUUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQWxGLFlBQVlLLE1BQU0sQ0FBQ0wsWUFBWW1GLElBQUk7SUFFbkMsT0FBT25GO0FBQ1I7QUFFQW9GLE9BQU9DLE9BQU8sR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/NWE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSIsImRlc3Ryb3kiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm5hbWVzIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwic2VsZWN0Q29sb3IiLCJuYW1lc3BhY2UiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJNYXRoIiwiYWJzIiwicHJldlRpbWUiLCJlbmFibGVPdmVycmlkZSIsIm5hbWVzcGFjZXNDYWNoZSIsImVuYWJsZWRDYWNoZSIsImFyZ3MiLCJzZWxmIiwiY3VyciIsIk51bWJlciIsIkRhdGUiLCJtcyIsImRpZmYiLCJwcmV2IiwidW5zaGlmdCIsImluZGV4IiwicmVwbGFjZSIsIm1hdGNoIiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwidmFsIiwiY2FsbCIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsImFwcGx5IiwidXNlQ29sb3JzIiwiY29sb3IiLCJleHRlbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJuYW1lc3BhY2VzIiwic2V0IiwidiIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInNhdmUiLCJzcGxpdCIsImxlbiIsInB1c2giLCJSZWdFeHAiLCJzbGljZSIsIm1hcCIsInRvTmFtZXNwYWNlIiwiam9pbiIsIm5hbWUiLCJ0ZXN0IiwicmVnZXhwIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJFcnJvciIsInN0YWNrIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9hZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxjQUFjRCxLQUFlLEtBQUssUUFBUUEsUUFBUUcsTUFBTSxFQUFFO0lBQ2hIQyw0SEFBeUI7QUFDMUIsT0FBTztJQUNOQSxzSEFBeUI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzP2QxZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInR5cGUiLCJicm93c2VyIiwiX19ud2pzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ const tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCOztDQUVDLEdBRURFLFlBQVksR0FBR0M7QUFDZkQsV0FBVyxHQUFHRTtBQUNkRixrQkFBa0IsR0FBR0c7QUFDckJILFlBQVksR0FBR0k7QUFDZkosWUFBWSxHQUFHSztBQUNmTCxpQkFBaUIsR0FBR007QUFDcEJOLGVBQWUsR0FBR0QsS0FBS1MsU0FBUyxDQUMvQixLQUFPLEdBQ1A7QUFHRDs7Q0FFQyxHQUVEUixjQUFjLEdBQUc7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUVuQyxJQUFJO0lBQ0gsMkdBQTJHO0lBQzNHLDZEQUE2RDtJQUM3RCxNQUFNVSxnQkFBZ0JaLG1CQUFPQSxDQUFDO0lBRTlCLElBQUlZLGlCQUFpQixDQUFDQSxjQUFjQyxNQUFNLElBQUlELGFBQVksRUFBR0UsS0FBSyxJQUFJLEdBQUc7UUFDeEVaLGNBQWMsR0FBRztZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNB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QUFXLEdBQUcsQ0FBQztJQUVyQixNQUFNRSxPQUFPRCxPQUFPQyxJQUFJLENBQUNoQixRQUFRYyxXQUFXO0lBQzVDLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSTFDLEtBQUsyQyxNQUFNLEVBQUVELElBQUs7UUFDckNELE1BQU0zQyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQyxHQUFHMUQsUUFBUWMsV0FBVyxDQUFDRSxJQUFJLENBQUMwQyxFQUFFLENBQUM7SUFDMUQ7QUFDRDtBQUVBWixPQUFPOUMsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyxtRkFBWUU7QUFFckMsTUFBTSxFQUFDNEQsVUFBVSxFQUFDLEdBQUdkLE9BQU85QyxPQUFPO0FBRW5DOztDQUVDLEdBRUQ0RCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXLEVBQ3JDNkIsS0FBSyxDQUFDLE1BQ05xQixHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFDbkJ0QixJQUFJLENBQUM7QUFDUjtBQUVBOztDQUVDLEdBRURnQixXQUFXTyxDQUFDLEdBQUcsU0FBVUwsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzc4MWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhleHBvcnRzLmluc3BlY3RPcHRzLCAuLi5hcmdzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHRpZiAobmFtZXNwYWNlcykge1xuXHRcdHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcblx0XHQvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuXHRcdGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRlYnVnKSB7XG5cdGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKHN0ciA9PiBzdHIudHJpbSgpKVxuXHRcdC5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG4iXSwibmFtZXMiOlsidHR5IiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwiaW5pdCIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsImRlc3Ryb3kiLCJkZXByZWNhdGUiLCJjb2xvcnMiLCJzdXBwb3J0c0NvbG9yIiwic3RkZXJyIiwibGV2ZWwiLCJlcnJvciIsImluc3BlY3RPcHRzIiwiT2JqZWN0Iiwia2V5cyIsInByb2Nlc3MiLCJlbnYiLCJmaWx0ZXIiLCJrZXkiLCJ0ZXN0IiwicmVkdWNlIiwib2JqIiwicHJvcCIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIl8iLCJrIiwidG9VcHBlckNhc2UiLCJ2YWwiLCJOdW1iZXIiLCJCb29sZWFuIiwiaXNhdHR5IiwiZmQiLCJhcmdzIiwibmFtZXNwYWNlIiwibmFtZSIsImMiLCJjb2xvciIsImNvbG9yQ29kZSIsInByZWZpeCIsInNwbGl0Iiwiam9pbiIsInB1c2giLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJnZXREYXRlIiwiaGlkZURhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ3cml0ZSIsImZvcm1hdFdpdGhPcHRpb25zIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwiZGVidWciLCJpIiwibGVuZ3RoIiwiZm9ybWF0dGVycyIsIm8iLCJ2IiwiaW5zcGVjdCIsIm1hcCIsInN0ciIsInRyaW0iLCJPIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/engine.io.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/engine.io.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.transports = exports.Server = void 0;\nexports.listen = listen;\nexports.attach = attach;\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/engine.io/build/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst index_1 = __webpack_require__(/*! ./transports/index */ \"(rsc)/./node_modules/engine.io/build/transports/index.js\");\nexports.transports = index_1.default;\nconst parser = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nexports.parser = parser;\nvar userver_1 = __webpack_require__(/*! ./userver */ \"(rsc)/./node_modules/engine.io/build/userver.js\");\nObject.defineProperty(exports, \"uServer\", ({\n    enumerable: true,\n    get: function() {\n        return userver_1.uServer;\n    }\n}));\nvar socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/engine.io/build/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({\n    enumerable: true,\n    get: function() {\n        return socket_1.Socket;\n    }\n}));\nvar transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nObject.defineProperty(exports, \"Transport\", ({\n    enumerable: true,\n    get: function() {\n        return transport_1.Transport;\n    }\n}));\nexports.protocol = parser.protocol;\n/**\n * Creates an http.Server exclusively used for WS upgrades.\n *\n * @param {Number} port\n * @param {Function} callback\n * @param {Object} options\n * @return {Server} websocket.io server\n */ function listen(port, options, fn) {\n    if (\"function\" === typeof options) {\n        fn = options;\n        options = {};\n    }\n    const server = (0, http_1.createServer)(function(req, res) {\n        res.writeHead(501);\n        res.end(\"Not Implemented\");\n    });\n    // create engine server\n    const engine = attach(server, options);\n    engine.httpServer = server;\n    server.listen(port, fn);\n    return engine;\n}\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @return {Server} engine server\n */ function attach(server, options) {\n    const engine = new server_1.Server(options);\n    engine.attach(server, options);\n    return engine;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL2VuZ2luZS5pby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdElBLGNBQWMsR0FBR1M7QUFDakJULGNBQWMsR0FBR1U7QUFDakIsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsZ0VBQVU7QUFDbkNkLDBDQUF5QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsU0FBU0wsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLE1BQU1RLFVBQVVKLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUM1Q1osa0JBQWtCLEdBQUdnQixRQUFRQyxPQUFPO0FBQ3BDLE1BQU1YLFNBQVNNLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUN6Q1osY0FBYyxHQUFHTTtBQUNqQixJQUFJWSxZQUFZTixtQkFBT0EsQ0FBQyxrRUFBVztBQUNuQ2QsMkNBQTBDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxVQUFVYixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0csSUFBSWMsV0FBV1AsbUJBQU9BLENBQUMsZ0VBQVU7QUFDakNkLDBDQUF5QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksU0FBU2YsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLElBQUlnQixjQUFjUixtQkFBT0EsQ0FBQyxzRUFBYTtBQUN2Q2QsNkNBQTRDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSyxZQUFZakIsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JISCxnQkFBZ0IsR0FBR00sT0FBT0osUUFBUTtBQUNsQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU08sT0FBT1ksSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEVBQUU7SUFDN0IsSUFBSSxlQUFlLE9BQU9ELFNBQVM7UUFDL0JDLEtBQUtEO1FBQ0xBLFVBQVUsQ0FBQztJQUNmO0lBQ0EsTUFBTUUsU0FBUyxDQUFDLEdBQUdiLE9BQU9jLFlBQVksRUFBRSxTQUFVQyxHQUFHLEVBQUVDLEdBQUc7UUFDdERBLElBQUlDLFNBQVMsQ0FBQztRQUNkRCxJQUFJRSxHQUFHLENBQUM7SUFDWjtJQUNBLHVCQUF1QjtJQUN2QixNQUFNQyxTQUFTcEIsT0FBT2MsUUFBUUY7SUFDOUJRLE9BQU9DLFVBQVUsR0FBR1A7SUFDcEJBLE9BQU9mLE1BQU0sQ0FBQ1ksTUFBTUU7SUFDcEIsT0FBT087QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNwQixPQUFPYyxNQUFNLEVBQUVGLE9BQU87SUFDM0IsTUFBTVEsU0FBUyxJQUFJakIsU0FBU0wsTUFBTSxDQUFDYztJQUNuQ1EsT0FBT3BCLE1BQU0sQ0FBQ2MsUUFBUUY7SUFDdEIsT0FBT1E7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL2VuZ2luZS5pby5qcz9iMDlmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm90b2NvbCA9IGV4cG9ydHMuVHJhbnNwb3J0ID0gZXhwb3J0cy5Tb2NrZXQgPSBleHBvcnRzLnVTZXJ2ZXIgPSBleHBvcnRzLnBhcnNlciA9IGV4cG9ydHMudHJhbnNwb3J0cyA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuZXhwb3J0cy5saXN0ZW4gPSBsaXN0ZW47XG5leHBvcnRzLmF0dGFjaCA9IGF0dGFjaDtcbmNvbnN0IGh0dHBfMSA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl8xLlNlcnZlcjsgfSB9KTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzL2luZGV4XCIpO1xuZXhwb3J0cy50cmFuc3BvcnRzID0gaW5kZXhfMS5kZWZhdWx0O1xuY29uc3QgcGFyc2VyID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbnZhciB1c2VydmVyXzEgPSByZXF1aXJlKFwiLi91c2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidVNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXNlcnZlcl8xLnVTZXJ2ZXI7IH0gfSk7XG52YXIgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvY2tldF8xLlNvY2tldDsgfSB9KTtcbnZhciB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zcG9ydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNwb3J0XzEuVHJhbnNwb3J0OyB9IH0pO1xuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcbi8qKlxuICogQ3JlYXRlcyBhbiBodHRwLlNlcnZlciBleGNsdXNpdmVseSB1c2VkIGZvciBXUyB1cGdyYWRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcG9ydFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTZXJ2ZXJ9IHdlYnNvY2tldC5pbyBzZXJ2ZXJcbiAqL1xuZnVuY3Rpb24gbGlzdGVuKHBvcnQsIG9wdGlvbnMsIGZuKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgZm4gPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlciA9ICgwLCBodHRwXzEuY3JlYXRlU2VydmVyKShmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgICAgICAgcmVzLndyaXRlSGVhZCg1MDEpO1xuICAgICAgICByZXMuZW5kKFwiTm90IEltcGxlbWVudGVkXCIpO1xuICAgIH0pO1xuICAgIC8vIGNyZWF0ZSBlbmdpbmUgc2VydmVyXG4gICAgY29uc3QgZW5naW5lID0gYXR0YWNoKHNlcnZlciwgb3B0aW9ucyk7XG4gICAgZW5naW5lLmh0dHBTZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgc2VydmVyLmxpc3Rlbihwb3J0LCBmbik7XG4gICAgcmV0dXJuIGVuZ2luZTtcbn1cbi8qKlxuICogQ2FwdHVyZXMgdXBncmFkZSByZXF1ZXN0cyBmb3IgYSBodHRwLlNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuU2VydmVyfSBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTZXJ2ZXJ9IGVuZ2luZSBzZXJ2ZXJcbiAqL1xuZnVuY3Rpb24gYXR0YWNoKHNlcnZlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBzZXJ2ZXJfMS5TZXJ2ZXIob3B0aW9ucyk7XG4gICAgZW5naW5lLmF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBlbmdpbmU7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwcm90b2NvbCIsIlRyYW5zcG9ydCIsIlNvY2tldCIsInVTZXJ2ZXIiLCJwYXJzZXIiLCJ0cmFuc3BvcnRzIiwiU2VydmVyIiwibGlzdGVuIiwiYXR0YWNoIiwiaHR0cF8xIiwicmVxdWlyZSIsInNlcnZlcl8xIiwiZW51bWVyYWJsZSIsImdldCIsImluZGV4XzEiLCJkZWZhdWx0IiwidXNlcnZlcl8xIiwic29ja2V0XzEiLCJ0cmFuc3BvcnRfMSIsInBvcnQiLCJvcHRpb25zIiwiZm4iLCJzZXJ2ZXIiLCJjcmVhdGVTZXJ2ZXIiLCJyZXEiLCJyZXMiLCJ3cml0ZUhlYWQiLCJlbmQiLCJlbmdpbmUiLCJodHRwU2VydmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/engine.io.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/parser-v3/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.packets = exports.protocol = void 0;\nexports.encodePacket = encodePacket;\nexports.encodeBase64Packet = encodeBase64Packet;\nexports.decodePacket = decodePacket;\nexports.decodeBase64Packet = decodeBase64Packet;\nexports.encodePayload = encodePayload;\nexports.decodePayload = decodePayload;\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n/**\n * Module dependencies.\n */ var utf8 = __webpack_require__(/*! ./utf8 */ \"(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js\");\n/**\n * Current protocol version.\n */ exports.protocol = 3;\nconst hasBinary = (packets)=>{\n    for (const packet of packets){\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Packet types.\n */ exports.packets = {\n    open: 0 // non-ws\n    ,\n    close: 1 // non-ws\n    ,\n    ping: 2,\n    pong: 3,\n    message: 4,\n    upgrade: 5,\n    noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */ var err = {\n    type: \"error\",\n    data: \"parser error\"\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */ function encodePacket(packet, supportsBinary, utf8encode, callback) {\n    if (typeof supportsBinary === \"function\") {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (typeof utf8encode === \"function\") {\n        callback = utf8encode;\n        utf8encode = null;\n    }\n    if (Buffer.isBuffer(packet.data)) {\n        return encodeBuffer(packet, supportsBinary, callback);\n    } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n        return encodeBuffer({\n            type: packet.type,\n            data: arrayBufferToBuffer(packet.data)\n        }, supportsBinary, callback);\n    }\n    // Sending data as a utf-8 string\n    var encoded = exports.packets[packet.type];\n    // data fragment is optional\n    if (undefined !== packet.data) {\n        encoded += utf8encode ? utf8.encode(String(packet.data), {\n            strict: false\n        }) : String(packet.data);\n    }\n    return callback(\"\" + encoded);\n}\n;\n/**\n * Encode Buffer data\n */ function encodeBuffer(packet, supportsBinary, callback) {\n    if (!supportsBinary) {\n        return encodeBase64Packet(packet, callback);\n    }\n    var data = packet.data;\n    var typeBuffer = Buffer.allocUnsafe(1);\n    typeBuffer[0] = exports.packets[packet.type];\n    return callback(Buffer.concat([\n        typeBuffer,\n        data\n    ]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */ function encodeBase64Packet(packet, callback) {\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n    var message = \"b\" + exports.packets[packet.type];\n    message += data.toString(\"base64\");\n    return callback(message);\n}\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */ function decodePacket(data, binaryType, utf8decode) {\n    if (data === undefined) {\n        return err;\n    }\n    var type;\n    // String data\n    if (typeof data === \"string\") {\n        type = data.charAt(0);\n        if (type === \"b\") {\n            return decodeBase64Packet(data.slice(1), binaryType);\n        }\n        if (utf8decode) {\n            data = tryDecode(data);\n            if (data === false) {\n                return err;\n            }\n        }\n        if (Number(type) != type || !packetslist[type]) {\n            return err;\n        }\n        if (data.length > 1) {\n            return {\n                type: packetslist[type],\n                data: data.slice(1)\n            };\n        } else {\n            return {\n                type: packetslist[type]\n            };\n        }\n    }\n    // Binary data\n    if (binaryType === \"arraybuffer\") {\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\n        var intArray = new Uint8Array(data);\n        type = intArray[0];\n        return {\n            type: packetslist[type],\n            data: intArray.buffer.slice(1)\n        };\n    }\n    if (data instanceof ArrayBuffer) {\n        data = arrayBufferToBuffer(data);\n    }\n    type = data[0];\n    return {\n        type: packetslist[type],\n        data: data.slice(1)\n    };\n}\n;\nfunction tryDecode(data) {\n    try {\n        data = utf8.decode(data, {\n            strict: false\n        });\n    } catch (e) {\n        return false;\n    }\n    return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */ function decodeBase64Packet(msg, binaryType) {\n    var type = packetslist[msg.charAt(0)];\n    var data = Buffer.from(msg.slice(1), \"base64\");\n    if (binaryType === \"arraybuffer\") {\n        var abv = new Uint8Array(data.length);\n        for(var i = 0; i < abv.length; i++){\n            abv[i] = data[i];\n        }\n        // @ts-ignore\n        data = abv.buffer;\n    }\n    return {\n        type: type,\n        data: data\n    };\n}\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */ function encodePayload(packets, supportsBinary, callback) {\n    if (typeof supportsBinary === \"function\") {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (supportsBinary && hasBinary(packets)) {\n        return encodePayloadAsBinary(packets, callback);\n    }\n    if (!packets.length) {\n        return callback(\"0:\");\n    }\n    function encodeOne(packet, doneCallback) {\n        encodePacket(packet, supportsBinary, false, function(message) {\n            doneCallback(null, setLengthHeader(message));\n        });\n    }\n    map(packets, encodeOne, function(err, results) {\n        return callback(results.join(\"\"));\n    });\n}\n;\nfunction setLengthHeader(message) {\n    return message.length + \":\" + message;\n}\n/**\n * Async array map using after\n */ function map(ary, each, done) {\n    const results = new Array(ary.length);\n    let count = 0;\n    for(let i = 0; i < ary.length; i++){\n        each(ary[i], (error, msg)=>{\n            results[i] = msg;\n            if (++count === ary.length) {\n                done(null, results);\n            }\n        });\n    }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */ function decodePayload(data, binaryType, callback) {\n    if (typeof data !== \"string\") {\n        return decodePayloadAsBinary(data, binaryType, callback);\n    }\n    if (typeof binaryType === \"function\") {\n        callback = binaryType;\n        binaryType = null;\n    }\n    if (data === \"\") {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n    var length = \"\", n, msg, packet;\n    for(var i = 0, l = data.length; i < l; i++){\n        var chr = data.charAt(i);\n        if (chr !== \":\") {\n            length += chr;\n            continue;\n        }\n        // @ts-ignore\n        if (length === \"\" || length != (n = Number(length))) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        msg = data.slice(i + 1, i + 1 + n);\n        if (length != msg.length) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        if (msg.length) {\n            packet = decodePacket(msg, binaryType, false);\n            if (err.type === packet.type && err.data === packet.data) {\n                // parser error in individual packet - ignoring payload\n                return callback(err, 0, 1);\n            }\n            var more = callback(packet, i + n, l);\n            if (false === more) return;\n        }\n        // advance cursor\n        i += n;\n        length = \"\";\n    }\n    if (length !== \"\") {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n}\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */ function bufferToString(buffer) {\n    var str = \"\";\n    for(var i = 0, l = buffer.length; i < l; i++){\n        str += String.fromCharCode(buffer[i]);\n    }\n    return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */ function stringToBuffer(string) {\n    var buf = Buffer.allocUnsafe(string.length);\n    for(var i = 0, l = string.length; i < l; i++){\n        buf.writeUInt8(string.charCodeAt(i), i);\n    }\n    return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */ function arrayBufferToBuffer(data) {\n    // data is either an ArrayBuffer or ArrayBufferView.\n    var length = data.byteLength || data.length;\n    var offset = data.byteOffset || 0;\n    return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */ function encodePayloadAsBinary(packets, callback) {\n    if (!packets.length) {\n        return callback(EMPTY_BUFFER);\n    }\n    map(packets, encodeOneBinaryPacket, function(err, results) {\n        return callback(Buffer.concat(results));\n    });\n}\n;\nfunction encodeOneBinaryPacket(p, doneCallback) {\n    function onBinaryPacketEncode(packet) {\n        var encodingLength = \"\" + packet.length;\n        var sizeBuffer;\n        if (typeof packet === \"string\") {\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\n            for(var i = 0; i < encodingLength.length; i++){\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n            }\n            sizeBuffer[sizeBuffer.length - 1] = 255;\n            return doneCallback(null, Buffer.concat([\n                sizeBuffer,\n                stringToBuffer(packet)\n            ]));\n        }\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\n        for(var i = 0; i < encodingLength.length; i++){\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n        }\n        sizeBuffer[sizeBuffer.length - 1] = 255;\n        doneCallback(null, Buffer.concat([\n            sizeBuffer,\n            packet\n        ]));\n    }\n    encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */ function decodePayloadAsBinary(data, binaryType, callback) {\n    if (typeof binaryType === \"function\") {\n        callback = binaryType;\n        binaryType = null;\n    }\n    var bufferTail = data;\n    var buffers = [];\n    var i;\n    while(bufferTail.length > 0){\n        var strLen = \"\";\n        var isString = bufferTail[0] === 0;\n        for(i = 1;; i++){\n            if (bufferTail[i] === 255) break;\n            // 310 = char length of Number.MAX_VALUE\n            if (strLen.length > 310) {\n                return callback(err, 0, 1);\n            }\n            strLen += \"\" + bufferTail[i];\n        }\n        bufferTail = bufferTail.slice(strLen.length + 1);\n        var msgLength = parseInt(strLen, 10);\n        var msg = bufferTail.slice(1, msgLength + 1);\n        if (isString) msg = bufferToString(msg);\n        buffers.push(msg);\n        bufferTail = bufferTail.slice(msgLength + 1);\n    }\n    var total = buffers.length;\n    for(i = 0; i < total; i++){\n        var buffer = buffers[i];\n        callback(decodePacket(buffer, binaryType, true), i, total);\n    }\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHdFQUF3RTtBQUN4RUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUMxQ0Esb0JBQW9CLEdBQUdJO0FBQ3ZCSiwwQkFBMEIsR0FBR0s7QUFDN0JMLG9CQUFvQixHQUFHTTtBQUN2Qk4sMEJBQTBCLEdBQUdPO0FBQzdCUCxxQkFBcUIsR0FBR1E7QUFDeEJSLHFCQUFxQixHQUFHUztBQUN4QlQsNkJBQTZCLEdBQUdVO0FBQ2hDViw2QkFBNkIsR0FBR1c7QUFDaEM7O0NBRUMsR0FDRCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQjs7Q0FFQyxHQUNEYixnQkFBZ0IsR0FBRztBQUNuQixNQUFNYyxZQUFZLENBQUNaO0lBQ2YsS0FBSyxNQUFNYSxVQUFVYixRQUFTO1FBQzFCLElBQUlhLE9BQU9DLElBQUksWUFBWUMsZUFBZUEsWUFBWUMsTUFBTSxDQUFDSCxPQUFPQyxJQUFJLEdBQUc7WUFDdkUsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNEaEIsZUFBZSxHQUFHO0lBQ2RtQixNQUFNLEVBQUUsU0FBUzs7SUFFakJDLE9BQU8sRUFBRSxTQUFTOztJQUVsQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxNQUFNO0FBQ1Y7QUFDQSxJQUFJQyxjQUFjNUIsT0FBTzZCLElBQUksQ0FBQzNCLFFBQVFFLE9BQU87QUFDN0M7O0NBRUMsR0FDRCxJQUFJMEIsTUFBTTtJQUFFQyxNQUFNO0lBQVNiLE1BQU07QUFBZTtBQUNoRCxNQUFNYyxlQUFlQyxPQUFPQyxNQUFNLENBQUMsRUFBRTtBQUNyQzs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVM1QixhQUFhVyxNQUFNLEVBQUVrQixj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QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My9pbmRleC5qcz9mYTBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLXBhcnNlci90cmVlLzIuMi54XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhY2tldHMgPSBleHBvcnRzLnByb3RvY29sID0gdm9pZCAwO1xuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBlbmNvZGVQYWNrZXQ7XG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGVuY29kZUJhc2U2NFBhY2tldDtcbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZGVjb2RlUGFja2V0O1xuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBkZWNvZGVCYXNlNjRQYWNrZXQ7XG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBlbmNvZGVQYXlsb2FkO1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZGVjb2RlUGF5bG9hZDtcbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmluYXJ5ID0gZW5jb2RlUGF5bG9hZEFzQmluYXJ5O1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBkZWNvZGVQYXlsb2FkQXNCaW5hcnk7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5jb25zdCBoYXNCaW5hcnkgPSAocGFja2V0cykgPT4ge1xuICAgIGZvciAoY29uc3QgcGFja2V0IG9mIHBhY2tldHMpIHtcbiAgICAgICAgaWYgKHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHBhY2tldC5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5leHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogMCAvLyBub24td3NcbiAgICAsXG4gICAgY2xvc2U6IDEgLy8gbm9uLXdzXG4gICAgLFxuICAgIHBpbmc6IDIsXG4gICAgcG9uZzogMyxcbiAgICBtZXNzYWdlOiA0LFxuICAgIHVwZ3JhZGU6IDUsXG4gICAgbm9vcDogNlxufTtcbnZhciBwYWNrZXRzbGlzdCA9IE9iamVjdC5rZXlzKGV4cG9ydHMucGFja2V0cyk7XG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmNvbmNhdChbXSk7XG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1dGY4ZW5jb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICAgICAgdXRmOGVuY29kZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWNrZXQuZGF0YSAmJiAocGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCdWZmZXIoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogYXJyYXlCdWZmZXJUb0J1ZmZlcihwYWNrZXQuZGF0YSkgfSwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gICAgdmFyIGVuY29kZWQgPSBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcbn1cbjtcbi8qKlxuICogRW5jb2RlIEJ1ZmZlciBkYXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICB2YXIgdHlwZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKTtcbiAgICB0eXBlQnVmZmVyWzBdID0gZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChbdHlwZUJ1ZmZlciwgZGF0YV0pKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSBCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpID8gcGFja2V0LmRhdGEgOiBhcnJheUJ1ZmZlclRvQnVmZmVyKHBhY2tldC5kYXRhKTtcbiAgICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gICAgbWVzc2FnZSArPSBkYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG47XG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIERhdGEgYWxzbyBhdmFpbGFibGUgYXMgYW4gQXJyYXlCdWZmZXIgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhY2tldChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICB2YXIgdHlwZTtcbiAgICAvLyBTdHJpbmcgZGF0YVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc2xpY2UoMSksIGJpbmFyeVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICAgICAgICBkYXRhID0gdHJ5RGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnNsaWNlKDEpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJpbmFyeSBkYXRhXG4gICAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgLy8gd3JhcCBCdWZmZXIvQXJyYXlCdWZmZXIgZGF0YSBpbnRvIGFuIFVpbnQ4QXJyYXlcbiAgICAgICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIHR5cGUgPSBpbnRBcnJheVswXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGludEFycmF5LmJ1ZmZlci5zbGljZSgxKSB9O1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBhcnJheUJ1ZmZlclRvQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgICB0eXBlID0gZGF0YVswXTtcbiAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zbGljZSgxKSB9O1xufVxuO1xuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0UGFja2V0KG1zZywgYmluYXJ5VHlwZSkge1xuICAgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gICAgdmFyIGRhdGEgPSBCdWZmZXIuZnJvbShtc2cuc2xpY2UoMSksICdiYXNlNjQnKTtcbiAgICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFidi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWJ2W2ldID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRhdGEgPSBhYnYuYnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59XG47XG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYXlsb2FkKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICAgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaGFzQmluYXJ5KHBhY2tldHMpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVQYXlsb2FkQXNCaW5hcnkocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gICAgfSk7XG59XG47XG5mdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG59XG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVhY2goYXJ5W2ldLCAoZXJyb3IsIG1zZykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IG1zZztcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBhcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWQoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSAnJywgbiwgbXNnLCBwYWNrZXQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaHIgIT09ICc6Jykge1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIG1zZyA9IGRhdGEuc2xpY2UoaSArIDEsIGkgKyAxICsgbik7XG4gICAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhY2tldCA9IGRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vcmUgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gbW9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgICAgaSArPSBuO1xuICAgICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gJycpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG59XG47XG4vKipcbiAqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIHV0ZjguanMgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKlxuICogQ29udmVydHMgYSB1dGY4LmpzIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnVmZmVyKHN0cmluZykge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHN0cmluZy5jaGFyQ29kZUF0KGkpLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbi8qKlxuICpcbiAqIENvbnZlcnRzIGFuIEFycmF5QnVmZmVyIHRvIGEgQnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CdWZmZXIoZGF0YSkge1xuICAgIC8vIGRhdGEgaXMgZWl0aGVyIGFuIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldy5cbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIgfHwgZGF0YSwgb2Zmc2V0LCBsZW5ndGgpO1xufVxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGF5bG9hZEFzQmluYXJ5KHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRU1QVFlfQlVGRkVSKTtcbiAgICB9XG4gICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZUJpbmFyeVBhY2tldCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgfSk7XG59XG47XG5mdW5jdGlvbiBlbmNvZGVPbmVCaW5hcnlQYWNrZXQocCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gb25CaW5hcnlQYWNrZXRFbmNvZGUocGFja2V0KSB7XG4gICAgICAgIHZhciBlbmNvZGluZ0xlbmd0aCA9ICcnICsgcGFja2V0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHNpemVCdWZmZXI7XG4gICAgICAgIGlmICh0eXBlb2YgcGFja2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgICAgICAgIHNpemVCdWZmZXJbMF0gPSAwOyAvLyBpcyBhIHN0cmluZyAobm90IHRydWUgYmluYXJ5ID0gMClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdMZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplQnVmZmVyW3NpemVCdWZmZXIubGVuZ3RoIC0gMV0gPSAyNTU7XG4gICAgICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoW3NpemVCdWZmZXIsIHN0cmluZ1RvQnVmZmVyKHBhY2tldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgICAgc2l6ZUJ1ZmZlclswXSA9IDE7IC8vIGlzIGJpbmFyeSAodHJ1ZSBiaW5hcnkgPSAxKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kaW5nTGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZUJ1ZmZlcltzaXplQnVmZmVyLmxlbmd0aCAtIDFdID0gMjU1O1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChbc2l6ZUJ1ZmZlciwgcGFja2V0XSkpO1xuICAgIH1cbiAgICBlbmNvZGVQYWNrZXQocCwgdHJ1ZSwgdHJ1ZSwgb25CaW5hcnlQYWNrZXRFbmNvZGUpO1xufVxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG5cbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoYnVmZmVyVGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdHJMZW4gPSAnJztcbiAgICAgICAgdmFyIGlzU3RyaW5nID0gYnVmZmVyVGFpbFswXSA9PT0gMDtcbiAgICAgICAgZm9yIChpID0gMTs7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclRhaWxbaV0gPT09IDI1NSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgICAgICAgIGlmIChzdHJMZW4ubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJMZW4gKz0gJycgKyBidWZmZXJUYWlsW2ldO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRhaWwgPSBidWZmZXJUYWlsLnNsaWNlKHN0ckxlbi5sZW5ndGggKyAxKTtcbiAgICAgICAgdmFyIG1zZ0xlbmd0aCA9IHBhcnNlSW50KHN0ckxlbiwgMTApO1xuICAgICAgICB2YXIgbXNnID0gYnVmZmVyVGFpbC5zbGljZSgxLCBtc2dMZW5ndGggKyAxKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKVxuICAgICAgICAgICAgbXNnID0gYnVmZmVyVG9TdHJpbmcobXNnKTtcbiAgICAgICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgICAgIGJ1ZmZlclRhaWwgPSBidWZmZXJUYWlsLnNsaWNlKG1zZ0xlbmd0aCArIDEpO1xuICAgIH1cbiAgICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2soZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgICB9XG59XG47XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYWNrZXRzIiwicHJvdG9jb2wiLCJlbmNvZGVQYWNrZXQiLCJlbmNvZGVCYXNlNjRQYWNrZXQiLCJkZWNvZGVQYWNrZXQiLCJkZWNvZGVCYXNlNjRQYWNrZXQiLCJlbmNvZGVQYXlsb2FkIiwiZGVjb2RlUGF5bG9hZCIsImVuY29kZVBheWxvYWRBc0JpbmFyeSIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsInV0ZjgiLCJyZXF1aXJlIiwiaGFzQmluYXJ5IiwicGFja2V0IiwiZGF0YSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3Iiwib3BlbiIsImNsb3NlIiwicGluZyIsInBvbmciLCJtZXNzYWdlIiwidXBncmFkZSIsIm5vb3AiLCJwYWNrZXRzbGlzdCIsImtleXMiLCJlcnIiLCJ0eXBlIiwiRU1QVFlfQlVGRkVSIiwiQnVmZmVyIiwiY29uY2F0Iiwic3VwcG9ydHNCaW5hcnkiLCJ1dGY4ZW5jb2RlIiwiY2FsbGJhY2siLCJpc0J1ZmZlciIsImVuY29kZUJ1ZmZlciIsImJ1ZmZlciIsImFycmF5QnVmZmVyVG9CdWZmZXIiLCJlbmNvZGVkIiwidW5kZWZpbmVkIiwiZW5jb2RlIiwiU3RyaW5nIiwic3RyaWN0IiwidHlwZUJ1ZmZlciIsImFsbG9jVW5zYWZlIiwidG9TdHJpbmciLCJiaW5hcnlUeXBlIiwidXRmOGRlY29kZSIsImNoYXJBdCIsInNsaWNlIiwidHJ5RGVjb2RlIiwiTnVtYmVyIiwibGVuZ3RoIiwiaW50QXJyYXkiLCJVaW50OEFycmF5IiwiZGVjb2RlIiwiZSIsIm1zZyIsImZyb20iLCJhYnYiLCJpIiwiZW5jb2RlT25lIiwiZG9uZUNhbGxiYWNrIiwic2V0TGVuZ3RoSGVhZGVyIiwibWFwIiwicmVzdWx0cyIsImpvaW4iLCJhcnkiLCJlYWNoIiwiZG9uZSIsIkFycmF5IiwiY291bnQiLCJlcnJvciIsIm4iLCJsIiwiY2hyIiwibW9yZSIsImJ1ZmZlclRvU3RyaW5nIiwic3RyIiwiZnJvbUNoYXJDb2RlIiwic3RyaW5nVG9CdWZmZXIiLCJzdHJpbmciLCJidWYiLCJ3cml0ZVVJbnQ4IiwiY2hhckNvZGVBdCIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJieXRlT2Zmc2V0IiwiZW5jb2RlT25lQmluYXJ5UGFja2V0IiwicCIsIm9uQmluYXJ5UGFja2V0RW5jb2RlIiwiZW5jb2RpbmdMZW5ndGgiLCJzaXplQnVmZmVyIiwicGFyc2VJbnQiLCJidWZmZXJUYWlsIiwiYnVmZmVycyIsInN0ckxlbiIsImlzU3RyaW5nIiwibXNnTGVuZ3RoIiwicHVzaCIsInRvdGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/parser-v3/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/utf8.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*! https://mths.be/utf8js v2.1.2 by @mathias */ var stringFromCharCode = String.fromCharCode;\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    var value;\n    var extra;\n    while(counter < length){\n        value = string.charCodeAt(counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // high surrogate, and there is a next character\n            extra = string.charCodeAt(counter++);\n            if ((extra & 0xFC00) == 0xDC00) {\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            } else {\n                // unmatched surrogate; only append this code unit, in case the next\n                // code unit is the high surrogate of a surrogate pair\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n    var length = array.length;\n    var index = -1;\n    var value;\n    var output = \"\";\n    while(++index < length){\n        value = array[index];\n        if (value > 0xFFFF) {\n            value -= 0x10000;\n            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n            value = 0xDC00 | value & 0x3FF;\n        }\n        output += stringFromCharCode(value);\n    }\n    return output;\n}\nfunction checkScalarValue(codePoint, strict) {\n    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n        if (strict) {\n            throw Error(\"Lone surrogate U+\" + codePoint.toString(16).toUpperCase() + \" is not a scalar value\");\n        }\n        return false;\n    }\n    return true;\n}\n/*--------------------------------------------------------------------------*/ function createByte(codePoint, shift) {\n    return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);\n}\nfunction encodeCodePoint(codePoint, strict) {\n    if ((codePoint & 0xFFFFFF80) == 0) {\n        return stringFromCharCode(codePoint);\n    }\n    var symbol = \"\";\n    if ((codePoint & 0xFFFFF800) == 0) {\n        symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);\n    } else if ((codePoint & 0xFFFF0000) == 0) {\n        if (!checkScalarValue(codePoint, strict)) {\n            codePoint = 0xFFFD;\n        }\n        symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);\n        symbol += createByte(codePoint, 6);\n    } else if ((codePoint & 0xFFE00000) == 0) {\n        symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);\n        symbol += createByte(codePoint, 12);\n        symbol += createByte(codePoint, 6);\n    }\n    symbol += stringFromCharCode(codePoint & 0x3F | 0x80);\n    return symbol;\n}\nfunction utf8encode(string, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    var codePoints = ucs2decode(string);\n    var length = codePoints.length;\n    var index = -1;\n    var codePoint;\n    var byteString = \"\";\n    while(++index < length){\n        codePoint = codePoints[index];\n        byteString += encodeCodePoint(codePoint, strict);\n    }\n    return byteString;\n}\n/*--------------------------------------------------------------------------*/ function readContinuationByte() {\n    if (byteIndex >= byteCount) {\n        throw Error(\"Invalid byte index\");\n    }\n    var continuationByte = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    if ((continuationByte & 0xC0) == 0x80) {\n        return continuationByte & 0x3F;\n    }\n    // If we end up here, it’s not a continuation byte\n    throw Error(\"Invalid continuation byte\");\n}\nfunction decodeSymbol(strict) {\n    var byte1;\n    var byte2;\n    var byte3;\n    var byte4;\n    var codePoint;\n    if (byteIndex > byteCount) {\n        throw Error(\"Invalid byte index\");\n    }\n    if (byteIndex == byteCount) {\n        return false;\n    }\n    // Read first byte\n    byte1 = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    // 1-byte sequence (no continuation bytes)\n    if ((byte1 & 0x80) == 0) {\n        return byte1;\n    }\n    // 2-byte sequence\n    if ((byte1 & 0xE0) == 0xC0) {\n        byte2 = readContinuationByte();\n        codePoint = (byte1 & 0x1F) << 6 | byte2;\n        if (codePoint >= 0x80) {\n            return codePoint;\n        } else {\n            throw Error(\"Invalid continuation byte\");\n        }\n    }\n    // 3-byte sequence (may include unpaired surrogates)\n    if ((byte1 & 0xF0) == 0xE0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;\n        if (codePoint >= 0x0800) {\n            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n        } else {\n            throw Error(\"Invalid continuation byte\");\n        }\n    }\n    // 4-byte sequence\n    if ((byte1 & 0xF8) == 0xF0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        byte4 = readContinuationByte();\n        codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;\n        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n            return codePoint;\n        }\n    }\n    throw Error(\"Invalid UTF-8 detected\");\n}\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    byteArray = ucs2decode(byteString);\n    byteCount = byteArray.length;\n    byteIndex = 0;\n    var codePoints = [];\n    var tmp;\n    while((tmp = decodeSymbol(strict)) !== false){\n        codePoints.push(tmp);\n    }\n    return ucs2encode(codePoints);\n}\nmodule.exports = {\n    version: \"2.1.2\",\n    encode: utf8encode,\n    decode: utf8decode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9wYXJzZXItdjMvdXRmOC5qcz9hOWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgZXh0cmE7XG4gICAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA+IDB4RkZGRikge1xuICAgICAgICAgICAgdmFsdWUgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgICAgICAgdmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuICAgIGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgJyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcbiAgICByZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5mdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpIHtcbiAgICBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICB9XG4gICAgdmFyIHN5bWJvbCA9ICcnO1xuICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgc3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG4gICAgICAgIGlmICghY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcbiAgICAgICAgc3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG4gICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcbiAgICAgICAgc3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcbiAgICB9XG4gICAgc3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuICAgIHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuICAgIHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgY29kZVBvaW50O1xuICAgIHZhciBieXRlU3RyaW5nID0gJyc7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgIGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmc7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuICAgIGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcbiAgICB9XG4gICAgdmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG4gICAgYnl0ZUluZGV4Kys7XG4gICAgaWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG4gICAgfVxuICAgIC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcbiAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xufVxuZnVuY3Rpb24gZGVjb2RlU3ltYm9sKHN0cmljdCkge1xuICAgIHZhciBieXRlMTtcbiAgICB2YXIgYnl0ZTI7XG4gICAgdmFyIGJ5dGUzO1xuICAgIHZhciBieXRlNDtcbiAgICB2YXIgY29kZVBvaW50O1xuICAgIGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgIH1cbiAgICBpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFJlYWQgZmlyc3QgYnl0ZVxuICAgIGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuICAgIGJ5dGVJbmRleCsrO1xuICAgIC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuICAgIGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHJldHVybiBieXRlMTtcbiAgICB9XG4gICAgLy8gMi1ieXRlIHNlcXVlbmNlXG4gICAgaWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcbiAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG4gICAgaWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcbiAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gNC1ieXRlIHNlcXVlbmNlXG4gICAgaWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcbiAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgY29kZVBvaW50ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcbiAgICAgICAgICAgIChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xufVxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcbiAgICBieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuICAgIGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG4gICAgYnl0ZUluZGV4ID0gMDtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciB0bXA7XG4gICAgd2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvZGVQb2ludHMucHVzaCh0bXApO1xuICAgIH1cbiAgICByZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb246ICcyLjEuMicsXG4gICAgZW5jb2RlOiB1dGY4ZW5jb2RlLFxuICAgIGRlY29kZTogdXRmOGRlY29kZVxufTtcbiJdLCJuYW1lcyI6WyJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ1Y3MyZGVjb2RlIiwic3RyaW5nIiwib3V0cHV0IiwiY291bnRlciIsImxlbmd0aCIsInZhbHVlIiwiZXh0cmEiLCJjaGFyQ29kZUF0IiwicHVzaCIsInVjczJlbmNvZGUiLCJhcnJheSIsImluZGV4IiwiY2hlY2tTY2FsYXJWYWx1ZSIsImNvZGVQb2ludCIsInN0cmljdCIsIkVycm9yIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZUJ5dGUiLCJzaGlmdCIsImVuY29kZUNvZGVQb2ludCIsInN5bWJvbCIsInV0ZjhlbmNvZGUiLCJvcHRzIiwiY29kZVBvaW50cyIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJieXRlQXJyYXkiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInV0ZjhkZWNvZGUiLCJ0bXAiLCJtb2R1bGUiLCJleHBvcnRzIiwidmVyc2lvbiIsImVuY29kZSIsImRlY29kZSJdLCJtYXBwaW5ncyI6IkFBQUEsOENBQThDLEdBQzlDLElBQUlBLHFCQUFxQkMsT0FBT0MsWUFBWTtBQUM1QyxzQ0FBc0M7QUFDdEMsU0FBU0MsV0FBV0MsTUFBTTtJQUN0QixJQUFJQyxTQUFTLEVBQUU7SUFDZixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsU0FBU0gsT0FBT0csTUFBTTtJQUMxQixJQUFJQztJQUNKLElBQUlDO0lBQ0osTUFBT0gsVUFBVUMsT0FBUTtRQUNyQkMsUUFBUUosT0FBT00sVUFBVSxDQUFDSjtRQUMxQixJQUFJRSxTQUFTLFVBQVVBLFNBQVMsVUFBVUYsVUFBVUMsUUFBUTtZQUN4RCxnREFBZ0Q7WUFDaERFLFFBQVFMLE9BQU9NLFVBQVUsQ0FBQ0o7WUFDMUIsSUFBSSxBQUFDRyxDQUFBQSxRQUFRLE1BQUssS0FBTSxRQUFRO2dCQUM1QkosT0FBT00sSUFBSSxDQUFDLEFBQUMsQ0FBQSxBQUFDSCxDQUFBQSxRQUFRLEtBQUksS0FBTSxFQUFDLElBQU1DLENBQUFBLFFBQVEsS0FBSSxJ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LGFBQWEsWUFBWUEsYUFBYSxVQUFVO1lBQ2hELE9BQU9BO1FBQ1g7SUFDSjtJQUNBLE1BQU1FLE1BQU07QUFDaEI7QUFDQSxJQUFJZTtBQUNKLElBQUlGO0FBQ0osSUFBSUQ7QUFDSixTQUFTUyxXQUFXWCxVQUFVLEVBQUVGLElBQUk7SUFDaENBLE9BQU9BLFFBQVEsQ0FBQztJQUNoQixJQUFJVCxTQUFTLFVBQVVTLEtBQUtULE1BQU07SUFDbENnQixZQUFZOUIsV0FBV3lCO0lBQ3ZCRyxZQUFZRSxVQUFVMUIsTUFBTTtJQUM1QnVCLFlBQVk7SUFDWixJQUFJSCxhQUFhLEVBQUU7SUFDbkIsSUFBSWE7SUFDSixNQUFPLEFBQUNBLENBQUFBLE1BQU1OLGFBQWFqQixPQUFNLE1BQU8sTUFBTztRQUMzQ1UsV0FBV2hCLElBQUksQ0FBQzZCO0lBQ3BCO0lBQ0EsT0FBTzVCLFdBQVdlO0FBQ3RCO0FBQ0FjLE9BQU9DLE9BQU8sR0FBRztJQUNiQyxTQUFTO0lBQ1RDLFFBQVFuQjtJQUNSb0IsUUFBUU47QUFDWiIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvcGFyc2VyLXYzL3V0ZjguanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/server.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = exports.BaseServer = void 0;\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst base64id = __webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\");\nconst transports_1 = __webpack_require__(/*! ./transports */ \"(rsc)/./node_modules/engine.io/build/transports/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/engine.io/build/socket.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst cookie_1 = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/index.js\");\nconst ws_1 = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst webtransport_1 = __webpack_require__(/*! ./transports/webtransport */ \"(rsc)/./node_modules/engine.io/build/transports/webtransport.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nfunction parseSessionId(data) {\n    try {\n        const parsed = JSON.parse(data);\n        if (typeof parsed.sid === \"string\") {\n            return parsed.sid;\n        }\n    } catch (e) {}\n}\nclass BaseServer extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     */ constructor(opts = {}){\n        super();\n        this.middlewares = [];\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: [\n                \"polling\",\n                \"websocket\"\n            ],\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024\n            },\n            cors: false,\n            allowEIO3: false\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\"\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.use(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\")(this.opts.cors));\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Compute the pathname of the requests that are handled by the server\n     * @param options\n     * @protected\n     */ _computePath(options) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        if (options.addTrailingSlash !== false) {\n            // normalize path\n            path += \"/\";\n        }\n        return path;\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     */ upgrades(transport) {\n        if (!this.opts.allowUpgrades) return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {EngineRequest} req\n     * @param upgrade - whether it's an upgrade request\n     * @param fn\n     * @protected\n     */ verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n        if (!~this.opts.transports.indexOf(transport) || transport === \"webtransport\") {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, {\n                transport\n            });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport\n                });\n            }\n        } else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method\n                });\n            }\n            if (transport === \"websocket\" && !upgrade) {\n                debug(\"invalid transport upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\"\n                });\n            }\n            if (!this.opts.allowRequest) return fn();\n            return this.opts.allowRequest(req, (message, success)=>{\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Adds a new middleware.\n     *\n     * @example\n     * import helmet from \"helmet\";\n     *\n     * engine.use(helmet());\n     *\n     * @param fn\n     */ use(fn) {\n        this.middlewares.push(fn);\n    }\n    /**\n     * Apply the middlewares to the request.\n     *\n     * @param req\n     * @param res\n     * @param callback\n     * @protected\n     */ _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            debug(\"no middleware to apply, skipping\");\n            return callback();\n        }\n        const apply = (i)=>{\n            debug(\"applying middleware n\\xb0%d\", i + 1);\n            this.middlewares[i](req, res, (err)=>{\n                if (err) {\n                    return callback(err);\n                }\n                if (i + 1 < this.middlewares.length) {\n                    apply(i + 1);\n                } else {\n                    callback();\n                }\n            });\n        };\n        apply(0);\n    }\n    /**\n     * Closes all clients.\n     */ close() {\n        debug(\"closing all open clients\");\n        for(let i in this.clients){\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        this.cleanup();\n        return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {IncomingMessage} req - the request object\n     */ generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transportName\n     * @param {Object} req - the request object\n     * @param {Function} closeConnection\n     *\n     * @protected\n     */ async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol\n                }\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        } catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = this.createTransport(transportName, req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            } else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n        } catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req)=>{\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", ()=>{\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n        return transport;\n    }\n    async onWebTransportSession(session) {\n        const timeout = setTimeout(()=>{\n            debug(\"the client failed to establish a bidirectional stream in the given period\");\n            session.close();\n        }, this.opts.upgradeTimeout);\n        const streamReader = session.incomingBidirectionalStreams.getReader();\n        const result = await streamReader.read();\n        if (result.done) {\n            debug(\"session is closed\");\n            return;\n        }\n        const stream = result.value;\n        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, \"nodebuffer\");\n        const reader = stream.readable.pipeThrough(transformStream).getReader();\n        // reading the first packet of the stream\n        const { value, done } = await reader.read();\n        if (done) {\n            debug(\"stream is closed\");\n            return;\n        }\n        clearTimeout(timeout);\n        if (value.type !== \"open\") {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        if (value.data === undefined) {\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n            const id = base64id.generateId();\n            debug('handshaking client \"%s\" (WebTransport)', id);\n            const socket = new socket_1.Socket(id, this, transport, null, 4);\n            this.clients[id] = socket;\n            this.clientsCount++;\n            socket.once(\"close\", ()=>{\n                delete this.clients[id];\n                this.clientsCount--;\n            });\n            this.emit(\"connection\", socket);\n            return;\n        }\n        const sid = parseSessionId(value.data);\n        if (!sid) {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        const client = this.clients[sid];\n        if (!client) {\n            debug(\"upgrade attempt for closed client\");\n            session.close();\n        } else if (client.upgrading) {\n            debug(\"transport has already been trying to upgrade\");\n            session.close();\n        } else if (client.upgraded) {\n            debug(\"transport had already been upgraded\");\n            session.close();\n        } else {\n            debug(\"upgrading existing transport\");\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            client._maybeUpgrade(transport);\n        }\n    }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */ BaseServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\"\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */ class WebSocketResponse {\n    constructor(req, socket){\n        this.req = req;\n        this.socket = socket;\n        // temporarily store the response headers on the req object (see the \"headers\" event)\n        req[kResponseHeaders] = {};\n    }\n    setHeader(name, value) {\n        this.req[kResponseHeaders][name] = value;\n    }\n    getHeader(name) {\n        return this.req[kResponseHeaders][name];\n    }\n    removeHeader(name) {\n        delete this.req[kResponseHeaders][name];\n    }\n    write() {}\n    writeHead() {}\n    end() {\n        // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n        this.socket.destroy();\n    }\n}\n/**\n * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.\n */ class Server extends BaseServer {\n    /**\n     * Initialize websocket server\n     *\n     * @protected\n     */ init() {\n        if (!~this.opts.transports.indexOf(\"websocket\")) return;\n        if (this.ws) this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req)=>{\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = req[kResponseHeaders] || {};\n                delete req[kResponseHeaders];\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                debug(\"writing headers: %j\", additionalHeaders);\n                Object.keys(additionalHeaders).forEach((key)=>{\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    cleanup() {\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n        // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */ prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n        }\n    }\n    createTransport(transportName, req) {\n        return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {EngineRequest} req\n     * @param {ServerResponse} res\n     */ handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        req.res = res;\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            } else {\n                const closeConnection = (errorCode, errorContext)=>abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     */ handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        const res = new WebSocketResponse(req, socket);\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead);\n            upgradeHead = null;\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            res.writeHead();\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, (websocket)=>{\n                this.onWebSocket(req, socket, websocket);\n            });\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @private\n     */ onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            } else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            } else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            } else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = this.createTransport(req._query.transport, req);\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n                client._maybeUpgrade(transport);\n            }\n        } else {\n            const closeConnection = (errorCode, errorContext)=>abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n        // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     */ attach(server, options = {}) {\n        const path = this._computePath(options);\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        function check(req) {\n            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n            return path === req.url.slice(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res)=>{\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            } else {\n                let i = 0;\n                const l = listeners.length;\n                for(; i < l; i++){\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head)=>{\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                } else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function() {\n                        // @ts-ignore\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            socket.on(\"error\", (e)=>{\n                                debug(\"error while destroying upgrade: %s\", e.message);\n                            });\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @private\n */ function abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, {\n        \"Content-Type\": \"application/json\"\n    });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n */ function abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", ()=>{\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */ /**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/ // prettier-ignore\nconst validHdrChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1) return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2) return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3) return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4) return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for(let i = 4; i < val.length; ++i){\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzNDLE1BQU1JLEtBQUtDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ2hDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLCtEQUFVO0FBQ25DLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLDhFQUFjO0FBQzNDLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ25DLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDLG9EQUFRO0FBQ2pDLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDLDRDQUFJO0FBQ3pCLE1BQU1TLGlCQUFpQlQsbUJBQU9BLENBQUMsa0dBQTJCO0FBQzFELE1BQU1VLHFCQUFxQlYsbUJBQU9BLENBQUMsa0ZBQWtCO0FBQ3JELE1BQU1XLFFBQVEsQ0FBQyxHQUFHTCxRQUFRTSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMsbUJBQW1CQyxPQUFPO0FBQ2hDLFNBQVNDLGVBQWVDLElBQUk7SUFDeEIsSUFBSTtRQUNBLE1BQU1DLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ0g7UUFDMUIsSUFBSSxPQUFPQyxPQUFPRyxHQUFHLEtBQUssVUFBVTtZQUNoQyxPQUFPSCxPQUFPRyxHQUFHO1FBQ3JCO0lBQ0osRUFDQSxPQUFPQyxHQUFHLENBQUU7QUFDaEI7QUFDQSxNQUFNdkIsbUJBQW1CTSxTQUFTa0IsWUFBWTtJQUMxQzs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FB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O0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLEVBQUUsVUFBVTtDQUM1RDtBQUNELFNBQVN4SCx1QkFBdUJ5SCxHQUFHO0lBQy9CQSxPQUFPO0lBQ1AsSUFBSUEsSUFBSXhHLE1BQU0sR0FBRyxHQUNiLE9BQU87SUFDWCxJQUFJLENBQUN1RyxhQUFhLENBQUNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDbkMvSyxNQUFNLHNDQUFzQzhLLElBQUlDLFVBQVUsQ0FBQztRQUMzRCxPQUFPO0lBQ1g7SUFDQSxJQUFJRCxJQUFJeEcsTUFBTSxHQUFHLEdBQ2IsT0FBTztJQUNYLElBQUksQ0FBQ3VHLGFBQWEsQ0FBQ0MsSUFBSUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNuQy9LLE1BQU0sc0NBQXNDOEssSUFBSUMsVUFBVSxDQUFDO1FBQzNELE9BQU87SUFDWDtJQUNBLElBQUlELElBQUl4RyxNQUFNLEdBQUcsR0FDYixPQUFPO0lBQ1gsSUFBSSxDQUFDdUcsYUFBYSxDQUFDQyxJQUFJQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ25DL0ssTUFBTSxzQ0FBc0M4SyxJQUFJQyxVQUFVLENBQUM7UUFDM0QsT0FBTztJQUNYO0lBQ0EsSUFBSUQsSUFBSXhHLE1BQU0sR0FBRyxHQUNiLE9BQU87SUFDWCxJQUFJLENBQUN1RyxhQUFhLENBQUNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDbkMvSyxNQUFNLHNDQUFzQzhLLElBQUlDLFVBQVUsQ0FBQztRQUMzRCxPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUl2RyxJQUFJLEdBQUdBLElBQUlzRyxJQUFJeEcsTUFBTSxFQUFFLEVBQUVFLEVBQUc7UUFDakMsSUFBSSxDQUFDcUcsYUFBYSxDQUFDQyxJQUFJQyxVQUFVLENBQUN2RyxHQUFHLEVBQUU7WUFDbkN4RSxNQUFNLHlDQUF5Q3dFLEdBQUdzRyxJQUFJQyxVQUFVLENBQUN2RztZQUNqRSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NlcnZlci5qcz82NTlkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXIgPSBleHBvcnRzLkJhc2VTZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBxcyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGJhc2U2NGlkID0gcmVxdWlyZShcImJhc2U2NGlkXCIpO1xuY29uc3QgdHJhbnNwb3J0c18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0c1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGNvb2tpZV8xID0gcmVxdWlyZShcImNvb2tpZVwiKTtcbmNvbnN0IHdzXzEgPSByZXF1aXJlKFwid3NcIik7XG5jb25zdCB3ZWJ0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0XCIpO1xuY29uc3QgZW5naW5lX2lvX3BhcnNlcl8xID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lXCIpO1xuY29uc3Qga1Jlc3BvbnNlSGVhZGVycyA9IFN5bWJvbChcInJlc3BvbnNlSGVhZGVyc1wiKTtcbmZ1bmN0aW9uIHBhcnNlU2Vzc2lvbklkKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5zaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQuc2lkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbn1cbmNsYXNzIEJhc2VTZXJ2ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFNlcnZlciBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmVzID0gW107XG4gICAgICAgIHRoaXMuY2xpZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmNsaWVudHNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgd3NFbmdpbmU6IHdzXzEuU2VydmVyLFxuICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IDIwMDAwLFxuICAgICAgICAgICAgcGluZ0ludGVydmFsOiAyNTAwMCxcbiAgICAgICAgICAgIHVwZ3JhZGVUaW1lb3V0OiAxMDAwMCxcbiAgICAgICAgICAgIG1heEh0dHBCdWZmZXJTaXplOiAxZTYsXG4gICAgICAgICAgICB0cmFuc3BvcnRzOiBbXCJwb2xsaW5nXCIsIFwid2Vic29ja2V0XCJdLCAvLyBXZWJUcmFuc3BvcnQgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgYWxsb3dVcGdyYWRlczogdHJ1ZSxcbiAgICAgICAgICAgIGh0dHBDb21wcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93RUlPMzogZmFsc2UsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICBpZiAob3B0cy5jb29raWUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5jb29raWUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImlvXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogXCIvXCIsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGh0dHBPbmx5OiBvcHRzLmNvb2tpZS5wYXRoICE9PSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICAgICAgICAgIH0sIG9wdHMuY29va2llKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvcnMpIHtcbiAgICAgICAgICAgIHRoaXMudXNlKHJlcXVpcmUoXCJjb3JzXCIpKHRoaXMub3B0cy5jb3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sIG9wdHMucGVyTWVzc2FnZURlZmxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBwYXRobmFtZSBvZiB0aGUgcmVxdWVzdHMgdGhhdCBhcmUgaGFuZGxlZCBieSB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NvbXB1dGVQYXRoKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8IFwiL2VuZ2luZS5pb1wiKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIGlmIChvcHRpb25zLmFkZFRyYWlsaW5nU2xhc2ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgcGF0aFxuICAgICAgICAgICAgcGF0aCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgZm9yIHVwZ3JhZGUgZ2l2ZW4gYSBjZXJ0YWluIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHVwZ3JhZGVzKHRyYW5zcG9ydCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5hbGxvd1VwZ3JhZGVzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0c18xLmRlZmF1bHRbdHJhbnNwb3J0XS51cGdyYWRlc1RvIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqIEBwYXJhbSB1cGdyYWRlIC0gd2hldGhlciBpdCdzIGFuIHVwZ3JhZGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBmblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB2ZXJpZnkocmVxLCB1cGdyYWRlLCBmbikge1xuICAgICAgICAvLyB0cmFuc3BvcnQgY2hlY2tcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gcmVxLl9xdWVyeS50cmFuc3BvcnQ7XG4gICAgICAgIC8vIFdlYlRyYW5zcG9ydCBkb2VzIG5vdCBnbyB0aHJvdWdoIHRoZSB2ZXJpZnkoKSBtZXRob2QsIHNlZSB0aGUgb25XZWJUcmFuc3BvcnRTZXNzaW9uKCkgbWV0aG9kXG4gICAgICAgIGlmICghfnRoaXMub3B0cy50cmFuc3BvcnRzLmluZGV4T2YodHJhbnNwb3J0KSB8fFxuICAgICAgICAgICAgdHJhbnNwb3J0ID09PSBcIndlYnRyYW5zcG9ydFwiKSB7XG4gICAgICAgICAgICBkZWJ1ZygndW5rbm93biB0cmFuc3BvcnQgXCIlc1wiJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLlVOS05PV05fVFJBTlNQT1JULCB7IHRyYW5zcG9ydCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAnT3JpZ2luJyBoZWFkZXIgY2hlY2tcbiAgICAgICAgY29uc3QgaXNPcmlnaW5JbnZhbGlkID0gY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcihyZXEuaGVhZGVycy5vcmlnaW4pO1xuICAgICAgICBpZiAoaXNPcmlnaW5JbnZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSByZXEuaGVhZGVycy5vcmlnaW47XG4gICAgICAgICAgICByZXEuaGVhZGVycy5vcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgZGVidWcoXCJvcmlnaW4gaGVhZGVyIGludmFsaWRcIik7XG4gICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiSU5WQUxJRF9PUklHSU5cIixcbiAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWQgY2hlY2tcbiAgICAgICAgY29uc3Qgc2lkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgIGlmIChzaWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRzLmhhc093blByb3BlcnR5KHNpZCkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygndW5rbm93biBzaWQgXCIlc1wiJywgc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5VTktOT1dOX1NJRCwge1xuICAgICAgICAgICAgICAgICAgICBzaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1RyYW5zcG9ydCA9IHRoaXMuY2xpZW50c1tzaWRdLnRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgaWYgKCF1cGdyYWRlICYmIHByZXZpb3VzVHJhbnNwb3J0ICE9PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImJhZCByZXF1ZXN0OiB1bmV4cGVjdGVkIHRyYW5zcG9ydCB3aXRob3V0IHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfTUlTTUFUQ0hcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRzaGFrZSBpcyBHRVQgb25seVxuICAgICAgICAgICAgaWYgKFwiR0VUXCIgIT09IHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfSEFORFNIQUtFX01FVEhPRCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBcIndlYnNvY2tldFwiICYmICF1cGdyYWRlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHRyYW5zcG9ydCB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVFJBTlNQT1JUX0hBTkRTSEFLRV9FUlJPUlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMuYWxsb3dSZXF1ZXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5hbGxvd1JlcXVlc3QocmVxLCAobWVzc2FnZSwgc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5GT1JCSURERU4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgaGVsbWV0IGZyb20gXCJoZWxtZXRcIjtcbiAgICAgKlxuICAgICAqIGVuZ2luZS51c2UoaGVsbWV0KCkpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGZuXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaChmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBtaWRkbGV3YXJlcyB0byB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5taWRkbGV3YXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlYnVnKFwibm8gbWlkZGxld2FyZSB0byBhcHBseSwgc2tpcHBpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseSA9IChpKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFwcGx5aW5nIG1pZGRsZXdhcmUgbsKwJWRcIiwgaSArIDEpO1xuICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlc1tpXShyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IHRoaXMubWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5KGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGFwcGx5KDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGNsaWVudHMuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZyBhbGwgb3BlbiBjbGllbnRzXCIpO1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuY2xpZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tpXS5jbG9zZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgc29ja2V0IGlkLlxuICAgICAqIE92ZXJ3cml0ZSB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB5b3VyIGN1c3RvbSBzb2NrZXQgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSByZXEgLSB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUlkKHJlcSkge1xuICAgICAgICByZXR1cm4gYmFzZTY0aWQuZ2VuZXJhdGVJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kc2hha2VzIGEgbmV3IGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnROYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcSAtIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb3NlQ29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRzaGFrZSh0cmFuc3BvcnROYW1lLCByZXEsIGNsb3NlQ29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS5fcXVlcnkuRUlPID09PSBcIjRcIiA/IDQgOiAzOyAvLyAzcmQgcmV2aXNpb24gYnkgZGVmYXVsdFxuICAgICAgICBpZiAocHJvdG9jb2wgPT09IDMgJiYgIXRoaXMub3B0cy5hbGxvd0VJTzMpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvblwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbU2VydmVyLmVycm9ycy5VTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlkID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUlkKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgZ2VuZXJhdGluZyBhbiBpZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1RdLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJJRF9HRU5FUkFUSU9OX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnaGFuZHNoYWtpbmcgY2xpZW50IFwiJXNcIicsIGlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpO1xuICAgICAgICAgICAgaWYgKFwicG9sbGluZ1wiID09PSB0cmFuc3BvcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm1heEh0dHBCdWZmZXJTaXplID0gdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5odHRwQ29tcHJlc3Npb24gPSB0aGlzLm9wdHMuaHR0cENvbXByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJ3ZWJzb2NrZXRcIiA9PT0gdHJhbnNwb3J0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoJ2Vycm9yIGhhbmRzaGFraW5nIHRvIHRyYW5zcG9ydCBcIiVzXCInLCB0cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1RdLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfSEFORFNIQUtFX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgc29ja2V0XzEuU29ja2V0KGlkLCB0aGlzLCB0cmFuc3BvcnQsIHJlcSwgcHJvdG9jb2wpO1xuICAgICAgICB0cmFuc3BvcnQub24oXCJoZWFkZXJzXCIsIChoZWFkZXJzLCByZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbFJlcXVlc3QgPSAhcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY29va2llKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJTZXQtQ29va2llXCJdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGNvb2tpZV8xLnNlcmlhbGl6ZSkodGhpcy5vcHRzLmNvb2tpZS5uYW1lLCBpZCwgdGhpcy5vcHRzLmNvb2tpZSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImluaXRpYWxfaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICB0aGlzLmNsaWVudHNbaWRdID0gc29ja2V0O1xuICAgICAgICB0aGlzLmNsaWVudHNDb3VudCsrO1xuICAgICAgICBzb2NrZXQub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzQ291bnQtLTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgb25XZWJUcmFuc3BvcnRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ0aGUgY2xpZW50IGZhaWxlZCB0byBlc3RhYmxpc2ggYSBiaWRpcmVjdGlvbmFsIHN0cmVhbSBpbiB0aGUgZ2l2ZW4gcGVyaW9kXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9LCB0aGlzLm9wdHMudXBncmFkZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBzdHJlYW1SZWFkZXIgPSBzZXNzaW9uLmluY29taW5nQmlkaXJlY3Rpb25hbFN0cmVhbXMuZ2V0UmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbVJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgZGVidWcoXCJzZXNzaW9uIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmVhbSA9ICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbSkodGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplLCBcIm5vZGVidWZmZXJcIik7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5yZWFkYWJsZS5waXBlVGhyb3VnaCh0cmFuc2Zvcm1TdHJlYW0pLmdldFJlYWRlcigpO1xuICAgICAgICAvLyByZWFkaW5nIHRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHN0cmVhbVxuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZGVidWcoXCJzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgV2ViVHJhbnNwb3J0IGhhbmRzaGFrZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IHdlYnRyYW5zcG9ydF8xLldlYlRyYW5zcG9ydChzZXNzaW9uLCBzdHJlYW0sIHJlYWRlcik7XG4gICAgICAgICAgICAvLyBub3RlOiB3ZSBjYW5ub3QgdXNlIFwidGhpcy5nZW5lcmF0ZUlkKClcIiwgYmVjYXVzZSB0aGVyZSBpcyBubyBcInJlcVwiIGFyZ3VtZW50XG4gICAgICAgICAgICBjb25zdCBpZCA9IGJhc2U2NGlkLmdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgIGRlYnVnKCdoYW5kc2hha2luZyBjbGllbnQgXCIlc1wiIChXZWJUcmFuc3BvcnQpJywgaWQpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IHNvY2tldF8xLlNvY2tldChpZCwgdGhpcywgdHJhbnNwb3J0LCBudWxsLCA0KTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50c1tpZF0gPSBzb2NrZXQ7XG4gICAgICAgICAgICB0aGlzLmNsaWVudHNDb3VudCsrO1xuICAgICAgICAgICAgc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2xpZW50c1tpZF07XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzQ291bnQtLTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZCA9IHBhcnNlU2Vzc2lvbklkKHZhbHVlLmRhdGEpO1xuICAgICAgICBpZiAoIXNpZCkge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIFdlYlRyYW5zcG9ydCBoYW5kc2hha2VcIik7XG4gICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50c1tzaWRdO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRlIGF0dGVtcHQgZm9yIGNsb3NlZCBjbGllbnRcIik7XG4gICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGluZykge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiB0cnlpbmcgdG8gdXBncmFkZVwiKTtcbiAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWRcIik7XG4gICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGluZyBleGlzdGluZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgd2VidHJhbnNwb3J0XzEuV2ViVHJhbnNwb3J0KHNlc3Npb24sIHN0cmVhbSwgcmVhZGVyKTtcbiAgICAgICAgICAgIGNsaWVudC5fbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VTZXJ2ZXIgPSBCYXNlU2VydmVyO1xuLyoqXG4gKiBQcm90b2NvbCBlcnJvcnMgbWFwcGluZ3MuXG4gKi9cbkJhc2VTZXJ2ZXIuZXJyb3JzID0ge1xuICAgIFVOS05PV05fVFJBTlNQT1JUOiAwLFxuICAgIFVOS05PV05fU0lEOiAxLFxuICAgIEJBRF9IQU5EU0hBS0VfTUVUSE9EOiAyLFxuICAgIEJBRF9SRVFVRVNUOiAzLFxuICAgIEZPUkJJRERFTjogNCxcbiAgICBVTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OOiA1LFxufTtcbkJhc2VTZXJ2ZXIuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAwOiBcIlRyYW5zcG9ydCB1bmtub3duXCIsXG4gICAgMTogXCJTZXNzaW9uIElEIHVua25vd25cIixcbiAgICAyOiBcIkJhZCBoYW5kc2hha2UgbWV0aG9kXCIsXG4gICAgMzogXCJCYWQgcmVxdWVzdFwiLFxuICAgIDQ6IFwiRm9yYmlkZGVuXCIsXG4gICAgNTogXCJVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uXCIsXG59O1xuLyoqXG4gKiBFeHBvc2VzIGEgc3Vic2V0IG9mIHRoZSBodHRwLlNlcnZlclJlc3BvbnNlIGludGVyZmFjZSwgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBhcHBseSB0aGUgbWlkZGxld2FyZXMgdG8gYW4gdXBncmFkZVxuICogcmVxdWVzdC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2NsYXNzLWh0dHBzZXJ2ZXJyZXNwb25zZVxuICovXG5jbGFzcyBXZWJTb2NrZXRSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVxLCBzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAvLyB0ZW1wb3JhcmlseSBzdG9yZSB0aGUgcmVzcG9uc2UgaGVhZGVycyBvbiB0aGUgcmVxIG9iamVjdCAoc2VlIHRoZSBcImhlYWRlcnNcIiBldmVudClcbiAgICAgICAgcmVxW2tSZXNwb25zZUhlYWRlcnNdID0ge307XG4gICAgfVxuICAgIHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlcVtrUmVzcG9uc2VIZWFkZXJzXVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXRIZWFkZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXFba1Jlc3BvbnNlSGVhZGVyc11bbmFtZV07XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlcVtrUmVzcG9uc2VIZWFkZXJzXVtuYW1lXTtcbiAgICB9XG4gICAgd3JpdGUoKSB7IH1cbiAgICB3cml0ZUhlYWQoKSB7IH1cbiAgICBlbmQoKSB7XG4gICAgICAgIC8vIHdlIGNvdWxkIHJldHVybiBhIHByb3BlciBlcnJvciBjb2RlLCBidXQgdGhlIFdlYlNvY2tldCBjbGllbnQgd2lsbCBlbWl0IGFuIFwiZXJyb3JcIiBldmVudCBhbnl3YXkuXG4gICAgICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIEVuZ2luZS5JTyBzZXJ2ZXIgYmFzZWQgb24gTm9kZS5qcyBidWlsdC1pbiBIVFRQIHNlcnZlciBhbmQgdGhlIGB3c2AgcGFja2FnZSBmb3IgV2ViU29ja2V0IGNvbm5lY3Rpb25zLlxuICovXG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyBCYXNlU2VydmVyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAoIX50aGlzLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy53cylcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy53cyA9IG5ldyB0aGlzLm9wdHMud3NFbmdpbmUoe1xuICAgICAgICAgICAgbm9TZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgICBjbGllbnRUcmFja2luZzogZmFsc2UsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndzLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub24oXCJoZWFkZXJzXCIsIChoZWFkZXJzQXJyYXksIHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG5vdGU6ICd3cycgdXNlcyBhbiBhcnJheSBvZiBoZWFkZXJzLCB3aGlsZSBFbmdpbmUuSU8gdXNlcyBhbiBvYmplY3QgKHJlc3BvbnNlLndyaXRlSGVhZCgpIGFjY2VwdHMgYm90aCBmb3JtYXRzKVxuICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIGFsc28gdHJ5IHRvIHBhcnNlIHRoZSBhcnJheSBhbmQgdGhlbiBzeW5jIHRoZSB2YWx1ZXMsIGJ1dCB0aGF0IHdpbGwgYmUgZXJyb3ItcHJvbmVcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsSGVhZGVycyA9IHJlcVtrUmVzcG9uc2VIZWFkZXJzXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxW2tSZXNwb25zZUhlYWRlcnNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbFJlcXVlc3QgPSAhcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaW5pdGlhbF9oZWFkZXJzXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid3JpdGluZyBoZWFkZXJzOiAlalwiLCBhZGRpdGlvbmFsSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzQXJyYXkucHVzaChgJHtrZXl9OiAke2FkZGl0aW9uYWxIZWFkZXJzW2tleV19YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgZGVidWcoXCJjbG9zaW5nIHdlYlNvY2tldFNlcnZlclwiKTtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIGRvbid0IGRlbGV0ZSB0aGlzLndzIGJlY2F1c2UgaXQgY2FuIGJlIHVzZWQgYWdhaW4gaWYgdGhlIGh0dHAgc2VydmVyIHN0YXJ0cyBsaXN0ZW5pbmcgYWdhaW5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhIHJlcXVlc3QgYnkgcHJvY2Vzc2luZyB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcmVwYXJlKHJlcSkge1xuICAgICAgICAvLyB0cnkgdG8gbGV2ZXJhZ2UgcHJlLWV4aXN0aW5nIGByZXEuX3F1ZXJ5YCAoZS5nOiBmcm9tIGNvbm5lY3QpXG4gICAgICAgIGlmICghcmVxLl9xdWVyeSkge1xuICAgICAgICAgICAgcmVxLl9xdWVyeSA9ICh+cmVxLnVybC5pbmRleE9mKFwiP1wiKSA/IHFzLnBhcnNlKCgwLCB1cmxfMS5wYXJzZSkocmVxLnVybCkucXVlcnkpIDoge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzXzEuZGVmYXVsdFt0cmFuc3BvcnROYW1lXShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIEVuZ2luZS5JTyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqIEBwYXJhbSB7U2VydmVyUmVzcG9uc2V9IHJlc1xuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgZGVidWcoJ2hhbmRsaW5nIFwiJXNcIiBodHRwIHJlcXVlc3QgXCIlc1wiJywgcmVxLm1ldGhvZCwgcmVxLnVybCk7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEpO1xuICAgICAgICByZXEucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXEuX3F1ZXJ5LnNpZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2V0dGluZyBuZXcgcmVxdWVzdCBmb3IgZXhpc3RpbmcgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tyZXEuX3F1ZXJ5LnNpZF0udHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VDb25uZWN0aW9uID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYW4gRW5naW5lLklPIEhUVFAgVXBncmFkZS5cbiAgICAgKi9cbiAgICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCB1cGdyYWRlSGVhZCkge1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFdlYlNvY2tldFJlc3BvbnNlKHJlcSwgc29ja2V0KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20odXBncmFkZUhlYWQpO1xuICAgICAgICAgICAgdXBncmFkZUhlYWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gc29tZSBtaWRkbGV3YXJlcyAobGlrZSBleHByZXNzLXNlc3Npb24pIHdhaXQgZm9yIHRoZSB3cml0ZUhlYWQoKSBjYWxsIHRvIGZsdXNoIHRoZWlyIGhlYWRlcnNcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL3Nlc3Npb24vYmxvYi8xMDEwZmFkYzJmMDcxZGRmMmFkZDk0MjM1ZDcyMjI0Y2Y2NTE1OWM2L2luZGV4LmpzI0wyMjAtTDI0NFxuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgpO1xuICAgICAgICAgICAgLy8gZGVsZWdhdGUgdG8gd3NcbiAgICAgICAgICAgIHRoaXMud3MuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgKHdlYnNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25XZWJTb2NrZXQocmVxLCBzb2NrZXQsIHdlYnNvY2tldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSB3cy5pbyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt3cy5Tb2NrZXR9IHdlYnNvY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25XZWJTb2NrZXQocmVxLCBzb2NrZXQsIHdlYnNvY2tldCkge1xuICAgICAgICB3ZWJzb2NrZXQub24oXCJlcnJvclwiLCBvblVwZ3JhZGVFcnJvcik7XG4gICAgICAgIGlmICh0cmFuc3BvcnRzXzEuZGVmYXVsdFtyZXEuX3F1ZXJ5LnRyYW5zcG9ydF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIXRyYW5zcG9ydHNfMS5kZWZhdWx0W3JlcS5fcXVlcnkudHJhbnNwb3J0XS5wcm90b3R5cGUuaGFuZGxlc1VwZ3JhZGVzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkb2VzbnQgaGFuZGxlIHVwZ3JhZGVkIHJlcXVlc3RzXCIpO1xuICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNsaWVudCBpZFxuICAgICAgICBjb25zdCBpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB3cy5Tb2NrZXRcbiAgICAgICAgcmVxLndlYnNvY2tldCA9IHdlYnNvY2tldDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYXMgYWxyZWFkeSBiZWVuIHRyeWluZyB0byB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFkIGFscmVhZHkgYmVlbiB1cGdyYWRlZFwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3BvcnQgZXJyb3IgaGFuZGxpbmcgdGFrZXMgb3ZlclxuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uVXBncmFkZUVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQucGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgICAgICAgICAgY2xpZW50Ll9tYXliZVVwZ3JhZGUodHJhbnNwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblVwZ3JhZGVFcnJvcigpIHtcbiAgICAgICAgICAgIGRlYnVnKFwid2Vic29ja2V0IGVycm9yIGJlZm9yZSB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgLy8gd2Vic29ja2V0LmNsb3NlKCkgbm90IG5lZWRlZFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHR1cmVzIHVwZ3JhZGUgcmVxdWVzdHMgZm9yIGEgaHR0cC5TZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyfSBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fY29tcHV0ZVBhdGgob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRlc3Ryb3lVcGdyYWRlVGltZW91dCA9IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGVUaW1lb3V0IHx8IDEwMDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHJlcSkge1xuICAgICAgICAgICAgLy8gVE9ETyB1c2UgYHBhdGggPT09IG5ldyBVUkwoLi4uKS5wYXRobmFtZWAgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSAocmVmOiBodHRwczovL25vZGVqcy5vcmcvYXBpL3VybC5odG1sKVxuICAgICAgICAgICAgcmV0dXJuIHBhdGggPT09IHJlcS51cmwuc2xpY2UoMCwgcGF0aC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIGFuZCBjbGVhbiB1cCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gc2VydmVyLmxpc3RlbmVycyhcInJlcXVlc3RcIikuc2xpY2UoMCk7XG4gICAgICAgIHNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZXF1ZXN0XCIpO1xuICAgICAgICBzZXJ2ZXIub24oXCJjbG9zZVwiLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXJ2ZXIub24oXCJsaXN0ZW5pbmdcIiwgdGhpcy5pbml0LmJpbmQodGhpcykpO1xuICAgICAgICAvLyBhZGQgcmVxdWVzdCBoYW5kbGVyXG4gICAgICAgIHNlcnZlci5vbihcInJlcXVlc3RcIiwgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2socmVxKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdpbnRlcmNlcHRpbmcgcmVxdWVzdCBmb3IgcGF0aCBcIiVzXCInLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlcnZlciwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh+dGhpcy5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZihcIndlYnNvY2tldFwiKSkge1xuICAgICAgICAgICAgc2VydmVyLm9uKFwidXBncmFkZVwiLCAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2socmVxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5kZXN0cm95VXBncmFkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG5vZGUgYmVoYXZpb3IgaXMgdG8gZGlzY29ubmVjdCB3aGVuIG5vIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBieSBhZGRpbmcgYSBoYW5kbGVyLCB3ZSBwcmV2ZW50IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vIGVpbyB0aGluZyBoYW5kbGVzIHRoZSB1cGdyYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIHNvY2tldCBuZWVkcyB0byBkaWUhXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBzb2NrZXQuYnl0ZXNXcml0dGVuIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIGRlc3Ryb3lpbmcgdXBncmFkZTogJXNcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZXN0cm95VXBncmFkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4vKipcbiAqIENsb3NlIHRoZSBIVFRQIGxvbmctcG9sbGluZyByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHJlcyAtIHRoZSByZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSBlcnJvckNvZGUgLSB0aGUgZXJyb3IgY29kZVxuICogQHBhcmFtIGVycm9yQ29udGV4dCAtIGFkZGl0aW9uYWwgZXJyb3IgY29udGV4dFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSB7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yQ29kZSA9PT0gU2VydmVyLmVycm9ycy5GT1JCSURERU4gPyA0MDMgOiA0MDA7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dCAmJiBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICA/IGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgIDogU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXTtcbiAgICByZXMud3JpdGVIZWFkKHN0YXR1c0NvZGUsIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XG4gICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KSk7XG59XG4vKipcbiAqIENsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JDb2RlIC0gdGhlIGVycm9yIGNvZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvckNvbnRleHQgLSBhZGRpdGlvbmFsIGVycm9yIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQgPSB7fSkge1xuICAgIHNvY2tldC5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgZGVidWcoXCJpZ25vcmluZyBlcnJvciBmcm9tIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIH0pO1xuICAgIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dC5tZXNzYWdlIHx8IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpO1xuICAgICAgICBzb2NrZXQud3JpdGUoXCJIVFRQLzEuMSA0MDAgQmFkIFJlcXVlc3RcXHJcXG5cIiArXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb246IGNsb3NlXFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJDb250ZW50LXR5cGU6IHRleHQvaHRtbFxcclxcblwiICtcbiAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGg6IFwiICtcbiAgICAgICAgICAgIGxlbmd0aCArXG4gICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgbWVzc2FnZSk7XG4gICAgfVxuICAgIHNvY2tldC5kZXN0cm95KCk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjQuMC9saWIvX2h0dHBfY29tbW9uLmpzI0wzMDMtTDM1NFxuICpcbiAqIFRydWUgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKlxuICogY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcigpIGlzIGN1cnJlbnRseSBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUgYnkgdjgsXG4gKiBzbyB0YWtlIGNhcmUgd2hlbiBtYWtpbmcgY2hhbmdlcyB0byB0aGUgaW1wbGVtZW50YXRpb24gc28gdGhhdCB0aGUgc291cmNlXG4gKiBjb2RlIHNpemUgZG9lcyBub3QgZXhjZWVkIHY4J3MgZGVmYXVsdCBtYXhfaW5saW5lZF9zb3VyY2Vfc2l6ZSBzZXR0aW5nLlxuICoqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB2YWxpZEhkckNoYXJzID0gW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyAzMiAtIDQ3XG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNDggLSA2M1xuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA4MCAtIDk1XG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAvLyAxMTIgLSAxMjdcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyAxMjggLi4uXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSAvLyAuLi4gMjU1XG5dO1xuZnVuY3Rpb24gY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcih2YWwpIHtcbiAgICB2YWwgKz0gXCJcIjtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMCldKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMCwgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMSldKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMSwgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgxKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA8IDMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMildKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMiwgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA8IDQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMyldKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMywgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgzKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gNDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IFwiJWlcIiwgY2hhciBcIiVzXCInLCBpLCB2YWwuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZXJ2ZXIiLCJCYXNlU2VydmVyIiwicXMiLCJyZXF1aXJlIiwidXJsXzEiLCJiYXNlNjRpZCIsInRyYW5zcG9ydHNfMSIsImV2ZW50c18xIiwic29ja2V0XzEiLCJkZWJ1Z18xIiwiY29va2llXzEiLCJ3c18xIiwid2VidHJhbnNwb3J0XzEiLCJlbmdpbmVfaW9fcGFyc2VyXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJrUmVzcG9uc2VIZWFkZXJzIiwiU3ltYm9sIiwicGFyc2VTZXNzaW9uSWQiLCJkYXRhIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwic2lkIiwiZSIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsIm1pZGRsZXdhcmVzIiwiY2xpZW50cyIsImNsaWVudHNDb3VudCIsImFzc2lnbiIsIndzRW5naW5lIiwicGluZ1RpbWVvdXQiLCJwaW5nSW50ZXJ2YWwiLCJ1cGdyYWRlVGltZW91dCIsIm1heEh0dHBCdWZmZXJTaXplIiwidHJhbnNwb3J0cyIsImFsbG93VXBncmFkZXMiLCJodHRwQ29tcHJlc3Npb24iLCJ0aHJlc2hvbGQiLCJjb3JzIiwiYWxsb3dFSU8zIiwiY29va2llIiwibmFtZSIsInBhdGgiLCJodHRwT25seSIsInNhbWVTaXRlIiwidXNlIiwicGVyTWVzc2FnZURlZmxhdGUiLCJpbml0IiwiX2NvbXB1dGVQYXRoIiwib3B0aW9ucyIsInJlcGxhY2UiLCJhZGRUcmFpbGluZ1NsYXNoIiwidXBncmFkZXMiLCJ0cmFuc3BvcnQiLCJ1cGdyYWRlc1RvIiwidmVyaWZ5IiwicmVxIiwidXBncmFkZSIsImZuIiwiX3F1ZXJ5IiwiaW5kZXhPZiIsImVycm9ycyIsIlVOS05PV05fVFJBTlNQT1JUIiwiaXNPcmlnaW5JbnZhbGlkIiwiY2hlY2tJbnZhbGlkSGVhZGVyQ2hhciIsImhlYWRlcnMiLCJvcmlnaW4iLCJCQURfUkVRVUVTVCIsImhhc093blByb3BlcnR5IiwiVU5LTk9XTl9TSUQiLCJwcmV2aW91c1RyYW5zcG9ydCIsIm1ldGhvZCIsIkJBRF9IQU5EU0hBS0VfTUVUSE9EIiwiYWxsb3dSZXF1ZXN0IiwibWVzc2FnZSIsInN1Y2Nlc3MiLCJGT1JCSURERU4iLCJwdXNoIiwiX2FwcGx5TWlkZGxld2FyZXMiLCJyZXMiLCJjYWxsYmFjayIsImxlbmd0aCIsImFwcGx5IiwiaSIsImVyciIsImNsb3NlIiwiY2xlYW51cCIsImdlbmVyYXRlSWQiLCJoYW5kc2hha2UiLCJ0cmFuc3BvcnROYW1lIiwiY2xvc2VDb25uZWN0aW9uIiwicHJvdG9jb2wiLCJFSU8iLCJlbWl0IiwiY29kZSIsIlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04iLCJlcnJvck1lc3NhZ2VzIiwiY29udGV4dCIsImlkIiwiZXJyb3IiLCJjcmVhdGVUcmFuc3BvcnQiLCJzb2NrZXQiLCJTb2NrZXQiLCJvbiIsImlzSW5pdGlhbFJlcXVlc3QiLCJzZXJpYWxpemUiLCJvblJlcXVlc3QiLCJvbmNlIiwib25XZWJUcmFuc3BvcnRTZXNzaW9uIiwic2Vzc2lvbiIsInRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic3RyZWFtUmVhZGVyIiwiaW5jb21pbmdCaWRpcmVjdGlvbmFsU3RyZWFtcyIsImdldFJlYWRlciIsInJlc3VsdCIsInJlYWQiLCJkb25lIiwic3RyZWFtIiwidHJhbnNmb3JtU3RyZWFtIiwiY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbSIsInJlYWRlciIsInJlYWRhYmxlIiwicGlwZVRocm91Z2giLCJjbGVhclRpbWVvdXQiLCJ0eXBlIiwidW5kZWZpbmVkIiwiV2ViVHJhbnNwb3J0IiwiY2xpZW50IiwidXBncmFkaW5nIiwidXBncmFkZWQiLCJfbWF5YmVVcGdyYWRlIiwiV2ViU29ja2V0UmVzcG9uc2UiLCJzZXRIZWFkZXIiLCJnZXRIZWFkZXIiLCJyZW1vdmVIZWFkZXIiLCJ3cml0ZSIsIndyaXRlSGVhZCIsImVuZCIsImRlc3Ryb3kiLCJ3cyIsIm5vU2VydmVyIiwiY2xpZW50VHJhY2tpbmciLCJtYXhQYXlsb2FkIiwiaGVhZGVyc0FycmF5IiwiYWRkaXRpb25hbEhlYWRlcnMiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInByZXBhcmUiLCJ1cmwiLCJxdWVyeSIsImhhbmRsZVJlcXVlc3QiLCJlcnJvckNvZGUiLCJlcnJvckNvbnRleHQiLCJhYm9ydFJlcXVlc3QiLCJoYW5kbGVVcGdyYWRlIiwidXBncmFkZUhlYWQiLCJhYm9ydFVwZ3JhZGUiLCJoZWFkIiwiQnVmZmVyIiwiZnJvbSIsIndlYnNvY2tldCIsIm9uV2ViU29ja2V0Iiwib25VcGdyYWRlRXJyb3IiLCJwcm90b3R5cGUiLCJoYW5kbGVzVXBncmFkZXMiLCJyZW1vdmVMaXN0ZW5lciIsImF0dGFjaCIsInNlcnZlciIsImRlc3Ryb3lVcGdyYWRlVGltZW91dCIsImNoZWNrIiwic2xpY2UiLCJsaXN0ZW5lcnMiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJiaW5kIiwibCIsImNhbGwiLCJkZXN0cm95VXBncmFkZSIsIndyaXRhYmxlIiwiYnl0ZXNXcml0dGVuIiwic3RhdHVzQ29kZSIsInN0cmluZ2lmeSIsImJ5dGVMZW5ndGgiLCJ2YWxpZEhkckNoYXJzIiwidmFsIiwiY2hhckNvZGVBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/socket.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/socket.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Socket = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst timers_1 = __webpack_require__(/*! timers */ \"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    constructor(id, server, transport, req, protocol){\n        super();\n        /**\n         * The current state of the socket.\n         */ this._readyState = \"opening\";\n        /* private */ this.upgrading = false;\n        /* private */ this.upgraded = false;\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.id = id;\n        this.server = server;\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req) {\n            if (req.websocket && req.websocket._socket) {\n                this.remoteAddress = req.websocket._socket.remoteAddress;\n            } else {\n                this.remoteAddress = req.connection.remoteAddress;\n            }\n        } else {\n        // TODO there is currently no way to get the IP address of the client when it connects with WebTransport\n        //  see https://github.com/fails-components/webtransport/issues/114\n        }\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @private\n     */ onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout();\n        } else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @private\n     */ onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        switch(packet.type){\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got ping\");\n                this.pingTimeoutTimer.refresh();\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got pong\");\n                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} err - error object\n     * @private\n     */ onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @private\n     */ schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(()=>{\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout();\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @private\n     */ resetPingTimeout() {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(()=>{\n            if (this.readyState === \"closed\") return;\n            this.onClose(\"ping timeout\");\n        }, this.protocol === 3 ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @private\n     */ setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onReady = ()=>this.flush();\n        const onPacket = this.onPacket.bind(this);\n        const onDrain = this.onDrain.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"ready\", onReady);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", onDrain);\n        this.transport.once(\"close\", onClose);\n        this.cleanupFn.push(function() {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"ready\", onReady);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", onDrain);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upon transport \"drain\" event\n     *\n     * @private\n     */ onDrain() {\n        if (this.sentCallbackFn.length > 0) {\n            debug(\"executing batch send callback\");\n            const seqFn = this.sentCallbackFn.shift();\n            if (seqFn) {\n                for(let i = 0; i < seqFn.length; i++){\n                    seqFn[i](this.transport);\n                }\n            }\n        }\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @private\n     */ /* private */ _maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(()=>{\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        let checkIntervalTimer;\n        const onPacket = (packet)=>{\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([\n                    {\n                        type: \"pong\",\n                        data: \"probe\"\n                    }\n                ]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(checkIntervalTimer);\n                checkIntervalTimer = setInterval(check, 100);\n            } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(()=>{\n                        this.onClose(\"forced close\");\n                    });\n                }\n            } else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = ()=>{\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([\n                    {\n                        type: \"noop\"\n                    }\n                ]);\n            }\n        };\n        const cleanup = ()=>{\n            this.upgrading = false;\n            clearInterval(checkIntervalTimer);\n            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = (err)=>{\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = ()=>{\n            onError(\"transport closed\");\n        };\n        const onClose = ()=>{\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @private\n     */ clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for(let i = 0; i < toCleanUp; i++){\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function() {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */ onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(()=>{\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     */ send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Alias of {@link send}.\n     *\n     * @param data\n     * @param options\n     * @param callback\n     */ write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @private\n     */ sendPacket(type, data, options = {}, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = {};\n        }\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            // compression is enabled by default\n            options.compress = options.compress !== false;\n            const packet = {\n                type,\n                options: options\n            };\n            if (data) packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (\"function\" === typeof callback) this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @private\n     */ flush() {\n        if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (this.packetsFn.length) {\n                this.sentCallbackFn.push(this.packetsFn);\n                this.packetsFn = [];\n            } else {\n                this.sentCallbackFn.push(null);\n            }\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @private\n     */ getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        for(let i = 0; i < allUpgrades.length; ++i){\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     */ close(discard) {\n        if (discard && (this.readyState === \"open\" || this.readyState === \"closing\")) {\n            return this.closeTransport(discard);\n        }\n        if (\"open\" !== this.readyState) return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            debug(\"there are %d remaining packets in the buffer, waiting for the 'drain' event\", this.writeBuffer.length);\n            this.once(\"drain\", ()=>{\n                debug(\"all packets have been sent, closing the transport\");\n                this.closeTransport(discard);\n            });\n            return;\n        }\n        debug(\"the buffer is empty, closing the transport right away\");\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @private\n     */ closeTransport(discard) {\n        debug(\"closing the transport (discard? %s)\", !!discard);\n        if (discard) this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsNkVBQU87QUFDL0IsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUcsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLE9BQU8sRUFBRTtBQUNuQyxNQUFNTixlQUFlQyxTQUFTTSxZQUFZO0lBQ3RDLElBQUlDLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ0MsV0FBVztJQUMzQjtJQUNBLElBQUlELFdBQVdFLEtBQUssRUFBRTtRQUNsQkwsTUFBTSxvQ0FBb0MsSUFBSSxDQUFDSSxXQUFXLEVBQUVDO1FBQzVELElBQUksQ0FBQ0QsV0FBVyxHQUFHQztJQUN2QjtJQUNBQyxZQUFZQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsQ0FBRTtRQUM5QyxLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNQLFdBQVcsR0FBRztRQUNuQixXQUFXLEdBQUcsSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDL0IsV0FBVyxHQUFHLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQzlCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDVixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDVSxPQUFPLEdBQUdSO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdB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QUFVLElBQUksQ0FBQ0EsVUFBVSxLQUFLLFNBQVEsR0FBSTtZQUMvRCxPQUFPLElBQUksQ0FBQzRGLGNBQWMsQ0FBQ25CO1FBQy9CO1FBQ0EsSUFBSSxXQUFXLElBQUksQ0FBQ3pFLFVBQVUsRUFDMUI7UUFDSixJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixJQUFJLElBQUksQ0FBQ1csV0FBVyxDQUFDK0MsTUFBTSxFQUFFO1lBQ3pCN0QsTUFBTSwrRUFBK0UsSUFBSSxDQUFDYyxXQUFXLENBQUMrQyxNQUFNO1lBQzVHLElBQUksQ0FBQ0osSUFBSSxDQUFDLFNBQVM7Z0JBQ2Z6RCxNQUFNO2dCQUNOLElBQUksQ0FBQytGLGNBQWMsQ0FBQ25CO1lBQ3hCO1lBQ0E7UUFDSjtRQUNBNUUsTUFBTTtRQUNOLElBQUksQ0FBQytGLGNBQWMsQ0FBQ25CO0lBQ3hCO0lBQ0E7Ozs7O0tBS0MsR0FDRG1CLGVBQWVuQixPQUFPLEVBQUU7UUFDcEI1RSxNQUFNLHVDQUF1QyxDQUFDLENBQUM0RTtRQUMvQyxJQUFJQSxTQUNBLElBQUksQ0FBQ25FLFNBQVMsQ0FBQ21FLE9BQU87UUFDMUIsSUFBSSxDQUFDbkUsU0FBUyxDQUFDNEQsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ0ksSUFBSSxDQUFDLElBQUksRUFBRTtJQUNqRDtBQUNKO0FBQ0E1RCxjQUFjLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvc29ja2V0LmpzP2M0NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB0aW1lcnNfMSA9IHJlcXVpcmUoXCJ0aW1lcnNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnNvY2tldFwiKTtcbmNsYXNzIFNvY2tldCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBzZXQgcmVhZHlTdGF0ZShzdGF0ZSkge1xuICAgICAgICBkZWJ1ZyhcInJlYWR5U3RhdGUgdXBkYXRlZCBmcm9tICVzIHRvICVzXCIsIHRoaXMuX3JlYWR5U3RhdGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpZCwgc2VydmVyLCB0cmFuc3BvcnQsIHJlcSwgcHJvdG9jb2wpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIC8qIHByaXZhdGUgKi8gdGhpcy51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyogcHJpdmF0ZSAqLyB0aGlzLnVwZ3JhZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wYWNrZXRzRm4gPSBbXTtcbiAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbiA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFudXBGbiA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXE7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgLy8gQ2FjaGUgSVAgc2luY2UgaXQgbWlnaHQgbm90IGJlIGluIHRoZSByZXEgbGF0ZXJcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgaWYgKHJlcS53ZWJzb2NrZXQgJiYgcmVxLndlYnNvY2tldC5fc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVxLndlYnNvY2tldC5fc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyB0aGVyZSBpcyBjdXJyZW50bHkgbm8gd2F5IHRvIGdldCB0aGUgSVAgYWRkcmVzcyBvZiB0aGUgY2xpZW50IHdoZW4gaXQgY29ubmVjdHMgd2l0aCBXZWJUcmFuc3BvcnRcbiAgICAgICAgICAgIC8vICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhaWxzLWNvbXBvbmVudHMvd2VidHJhbnNwb3J0L2lzc3Vlcy8xMTRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNvbnNpZGVyZWQgb3Blbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgLy8gc2VuZHMgYW4gYG9wZW5gIHBhY2tldFxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJvcGVuXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHVwZ3JhZGVzOiB0aGlzLmdldEF2YWlsYWJsZVVwZ3JhZGVzKCksXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWw6IHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsLFxuICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXQsXG4gICAgICAgICAgICBtYXhQYXlsb2FkOiB0aGlzLnNlcnZlci5vcHRzLm1heEh0dHBCdWZmZXJTaXplLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5vcHRzLmluaXRpYWxQYWNrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgdGhpcy5zZXJ2ZXIub3B0cy5pbml0aWFsUGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgLy8gaW4gcHJvdG9jb2wgdjMsIHRoZSBjbGllbnQgc2VuZHMgYSBwaW5nLCBhbmQgdGhlIHNlcnZlciBhbnN3ZXJzIHdpdGggYSBwb25nXG4gICAgICAgICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIHByb3RvY29sIHY0LCB0aGUgc2VydmVyIHNlbmRzIGEgcGluZywgYW5kIHRoZSBjbGllbnQgYW5zd2VycyB3aXRoIGEgcG9uZ1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGlmIChcIm9wZW5cIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVidWcoXCJwYWNrZXQgcmVjZWl2ZWQgd2l0aCBjbG9zZWQgc29ja2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cG9ydCBwYWNrZXQgZXZlbnRcbiAgICAgICAgZGVidWcoYHJlY2VpdmVkIHBhY2tldCAke3BhY2tldC50eXBlfWApO1xuICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQucHJvdG9jb2wgIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcImludmFsaWQgaGVhcnRiZWF0IGRpcmVjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcGluZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBvbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcImludmFsaWQgaGVhcnRiZWF0IGRpcmVjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcG9uZ1wiKTtcbiAgICAgICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShcInBhcnNlIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBlcnJvciBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGVycm9yXCIpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGluZ3MgY2xpZW50IGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAgICAgKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzY2hlZHVsZVBpbmcoKSB7XG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSAoMCwgdGltZXJzXzEuc2V0VGltZW91dCkoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXNcIiwgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwaW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgIH0sIHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2VkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCB0aGlzLnByb3RvY29sID09PSAzXG4gICAgICAgICAgICA/IHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsICsgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dFxuICAgICAgICAgICAgOiB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHRoaXMuZmx1c2goKTtcbiAgICAgICAgY29uc3Qgb25QYWNrZXQgPSB0aGlzLm9uUGFja2V0LmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9uRHJhaW4gPSB0aGlzLm9uRHJhaW4uYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMsIFwidHJhbnNwb3J0IGNsb3NlXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcInJlYWR5XCIsIG9uUmVhZHkpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZHJhaW5cIiwgb25EcmFpbik7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwRm4ucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInJlYWR5XCIsIG9uUmVhZHkpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsIG9uRHJhaW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcG9uIHRyYW5zcG9ydCBcImRyYWluXCIgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VudENhbGxiYWNrRm4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcoXCJleGVjdXRpbmcgYmF0Y2ggc2VuZCBjYWxsYmFja1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcUZuID0gdGhpcy5zZW50Q2FsbGJhY2tGbi5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHNlcUZuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXFGbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZXFGbltpXSh0aGlzLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZ3JhZGVzIHNvY2tldCB0byB0aGUgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvKiBwcml2YXRlICovIF9tYXliZVVwZ3JhZGUodHJhbnNwb3J0KSB7XG4gICAgICAgIGRlYnVnKCdtaWdodCB1cGdyYWRlIHNvY2tldCB0cmFuc3BvcnQgZnJvbSBcIiVzXCIgdG8gXCIlc1wiJywgdGhpcy50cmFuc3BvcnQubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIC8vIHNldCB0cmFuc3BvcnQgdXBncmFkZSB0aW1lclxuICAgICAgICBjb25zdCB1cGdyYWRlVGltZW91dFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xpZW50IGRpZCBub3QgY29tcGxldGUgdXBncmFkZSAtIGNsb3NpbmcgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKFwib3BlblwiID09PSB0cmFuc3BvcnQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnNlcnZlci5vcHRzLnVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgbGV0IGNoZWNrSW50ZXJ2YWxUaW1lcjtcbiAgICAgICAgY29uc3Qgb25QYWNrZXQgPSAocGFja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwaW5nXCIgPT09IHBhY2tldC50eXBlICYmIFwicHJvYmVcIiA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCBwcm9iZSBwaW5nIHBhY2tldCwgc2VuZGluZyBwb25nXCIpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwicG9uZ1wiLCBkYXRhOiBcInByb2JlXCIgfV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICAgICBjaGVja0ludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChjaGVjaywgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwidXBncmFkZVwiID09PSBwYWNrZXQudHlwZSAmJiB0aGlzLnJlYWR5U3RhdGUgIT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCB1cGdyYWRlIHBhY2tldCAtIHVwZ3JhZGluZ1wiKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY2FyZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZ3JhZGVcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjbG9zaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBmb3JjZSBhIHBvbGxpbmcgY3ljbGUgdG8gZW5zdXJlIGEgZmFzdCB1cGdyYWRlXG4gICAgICAgIGNvbnN0IGNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKFwicG9sbGluZ1wiID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIGEgbm9vcCBwYWNrZXQgdG8gcG9sbGluZyBmb3IgZmFzdCB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHVwZ3JhZGVUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsaWVudCBkaWQgbm90IGNvbXBsZXRlIHVwZ3JhZGUgLSAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblRyYW5zcG9ydENsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgb25FcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBvbkVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBsaXN0ZW5lcnMgYW5kIHRpbWVycyBhc3NvY2lhdGVkIHdpdGggY3VycmVudCB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFyVHJhbnNwb3J0KCkge1xuICAgICAgICBsZXQgY2xlYW51cDtcbiAgICAgICAgY29uc3QgdG9DbGVhblVwID0gdGhpcy5jbGVhbnVwRm4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvQ2xlYW5VcDsgaSsrKSB7XG4gICAgICAgICAgICBjbGVhbnVwID0gdGhpcy5jbGVhbnVwRm4uc2hpZnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWxlbmNlIGZ1cnRoZXIgdHJhbnNwb3J0IGVycm9ycyBhbmQgcHJldmVudCB1bmNhdWdodCBleGNlcHRpb25zXG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoXCJlcnJvciB0cmlnZ2VyZWQgYnkgZGlzY2FyZGVkIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjb25zaWRlcmVkIGNsb3NlZC5cbiAgICAgKiBQb3NzaWJsZSByZWFzb25zOiBgcGluZyB0aW1lb3V0YCwgYGNsaWVudCBlcnJvcmAsIGBwYXJzZSBlcnJvcmAsXG4gICAgICogYHRyYW5zcG9ydCBlcnJvcmAsIGBzZXJ2ZXIgY2xvc2VgLCBgdHJhbnNwb3J0IGNsb3NlYFxuICAgICAqL1xuICAgIG9uQ2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgLy8gY2xlYXIgdGltZXJzXG4gICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAvLyBjbGVhbiB3cml0ZUJ1ZmZlciBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBncmFiIHRoZSB3cml0ZUJ1ZmZlciBvbiAnY2xvc2UnIGV2ZW50XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLmNsZWFyVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2Yge0BsaW5rIHNlbmR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHBhY2tldCB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlbmRQYWNrZXQodHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImNsb3NpbmdcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NlbmRpbmcgcGFja2V0IFwiJXNcIiAoJXMpJywgdHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcHJlc3MgPSBvcHRpb25zLmNvbXByZXNzICE9PSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgcGFja2V0LmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgLy8gZXhwb3J0cyBwYWNrZXRDcmVhdGUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBhY2tldENyZWF0ZVwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICAgICAgICAvLyBhZGQgc2VuZCBjYWxsYmFjayB0byBvYmplY3QsIGlmIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHNGbi5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmbHVzaCB0aGUgcGFja2V0cyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZmx1c2hpbmcgYnVmZmVyIHRvIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImZsdXNoXCIsIHRoaXMud3JpdGVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZW1pdChcImZsdXNoXCIsIHRoaXMsIHRoaXMud3JpdGVCdWZmZXIpO1xuICAgICAgICAgICAgY29uc3Qgd2J1ZiA9IHRoaXMud3JpdGVCdWZmZXI7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5wYWNrZXRzRm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbi5wdXNoKHRoaXMucGFja2V0c0ZuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbi5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh3YnVmKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZW1pdChcImRyYWluXCIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdmFpbGFibGUgdXBncmFkZXMgZm9yIHRoaXMgc29ja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBdmFpbGFibGVVcGdyYWRlcygpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlVXBncmFkZXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsVXBncmFkZXMgPSB0aGlzLnNlcnZlci51cGdyYWRlcyh0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxVcGdyYWRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdXBnID0gYWxsVXBncmFkZXNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXIub3B0cy50cmFuc3BvcnRzLmluZGV4T2YodXBnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVVcGdyYWRlcy5wdXNoKHVwZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVVwZ3JhZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHNvY2tldCBhbmQgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2NhcmQgLSBvcHRpb25hbCwgZGlzY2FyZCB0aGUgdHJhbnNwb3J0XG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBjbG9zZShkaXNjYXJkKSB7XG4gICAgICAgIGlmIChkaXNjYXJkICYmXG4gICAgICAgICAgICAodGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2luZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwib3BlblwiICE9PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2luZ1wiO1xuICAgICAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidGhlcmUgYXJlICVkIHJlbWFpbmluZyBwYWNrZXRzIGluIHRoZSBidWZmZXIsIHdhaXRpbmcgZm9yIHRoZSAnZHJhaW4nIGV2ZW50XCIsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImFsbCBwYWNrZXRzIGhhdmUgYmVlbiBzZW50LCBjbG9zaW5nIHRoZSB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVRyYW5zcG9ydChkaXNjYXJkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwidGhlIGJ1ZmZlciBpcyBlbXB0eSwgY2xvc2luZyB0aGUgdHJhbnNwb3J0IHJpZ2h0IGF3YXlcIik7XG4gICAgICAgIHRoaXMuY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2NhcmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIHRoZSB0cmFuc3BvcnQgKGRpc2NhcmQ/ICVzKVwiLCAhIWRpc2NhcmQpO1xuICAgICAgICBpZiAoZGlzY2FyZClcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2NhcmQoKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UodGhpcy5vbkNsb3NlLmJpbmQodGhpcywgXCJmb3JjZWQgY2xvc2VcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU29ja2V0IiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsInRpbWVyc18xIiwiZGVidWciLCJkZWZhdWx0IiwiRXZlbnRFbWl0dGVyIiwicmVhZHlTdGF0ZSIsIl9yZWFkeVN0YXRlIiwic3RhdGUiLCJjb25zdHJ1Y3RvciIsImlkIiwic2VydmVyIiwidHJhbnNwb3J0IiwicmVxIiwicHJvdG9jb2wiLCJ1cGdyYWRpbmciLCJ1cGdyYWRlZCIsIndyaXRlQnVmZmVyIiwicGFja2V0c0ZuIiwic2VudENhbGxiYWNrRm4iLCJjbGVhbnVwRm4iLCJyZXF1ZXN0Iiwid2Vic29ja2V0IiwiX3NvY2tldCIsInJlbW90ZUFkZHJlc3MiLCJjb25uZWN0aW9uIiwicGluZ1RpbWVvdXRUaW1lciIsInBpbmdJbnRlcnZhbFRpbWVyIiwic2V0VHJhbnNwb3J0Iiwib25PcGVuIiwic2lkIiwic2VuZFBhY2tldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGdyYWRlcyIsImdldEF2YWlsYWJsZVVwZ3JhZGVzIiwicGluZ0ludGVydmFsIiwib3B0cyIsInBpbmdUaW1lb3V0IiwibWF4UGF5bG9hZCIsIm1heEh0dHBCdWZmZXJTaXplIiwiaW5pdGlhbFBhY2tldCIsImVtaXQiLCJyZXNldFBpbmdUaW1lb3V0Iiwic2NoZWR1bGVQaW5nIiwib25QYWNrZXQiLCJwYWNrZXQiLCJ0eXBlIiwib25FcnJvciIsIkVycm9yIiwicmVmcmVzaCIsImNsZWFyVGltZW91dCIsIm9uQ2xvc2UiLCJkYXRhIiwiZXJyIiwic2V0VGltZW91dCIsImJpbmQiLCJvblJlYWR5IiwiZmx1c2giLCJvbkRyYWluIiwib25jZSIsIm9uIiwicHVzaCIsInJlbW92ZUxpc3RlbmVyIiwibGVuZ3RoIiwic2VxRm4iLCJzaGlmdCIsImkiLCJfbWF5YmVVcGdyYWRlIiwibmFtZSIsInVwZ3JhZGVUaW1lb3V0VGltZXIiLCJjbGVhbnVwIiwiY2xvc2UiLCJ1cGdyYWRlVGltZW91dCIsImNoZWNrSW50ZXJ2YWxUaW1lciIsInNlbmQiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjaGVjayIsImRpc2NhcmQiLCJjbGVhclRyYW5zcG9ydCIsIndyaXRhYmxlIiwib25UcmFuc3BvcnRDbG9zZSIsInRvQ2xlYW5VcCIsInJlYXNvbiIsImRlc2NyaXB0aW9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib3B0aW9ucyIsImNhbGxiYWNrIiwid3JpdGUiLCJjb21wcmVzcyIsIndidWYiLCJhdmFpbGFibGVVcGdyYWRlcyIsImFsbFVwZ3JhZGVzIiwidXBnIiwidHJhbnNwb3J0cyIsImluZGV4T2YiLCJjbG9zZVRyYW5zcG9ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transport.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/transport.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Transport = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst parser_v4 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst parser_v3 = __webpack_require__(/*! ./parser-v3/index */ \"(rsc)/./node_modules/engine.io/build/parser-v3/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:transport\");\nfunction noop() {}\nclass Transport extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s (%s)\", this._readyState, state, this.name);\n        this._readyState = state;\n    }\n    /**\n     * Transport constructor.\n     *\n     * @param {EngineRequest} req\n     */ constructor(req){\n        super();\n        /**\n         * Whether the transport is currently ready to send packets.\n         */ this.writable = false;\n        /**\n         * The current state of the transport.\n         * @protected\n         */ this._readyState = \"open\";\n        /**\n         * Whether the transport is discarded and can be safely closed (used during upgrade).\n         * @protected\n         */ this.discarded = false;\n        this.protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;\n        this.supportsBinary = !(req._query && req._query.b64);\n    }\n    /**\n     * Flags the transport as discarded.\n     *\n     * @package\n     */ discard() {\n        this.discarded = true;\n    }\n    /**\n     * Called with an incoming HTTP request.\n     *\n     * @param req\n     * @package\n     */ onRequest(req) {}\n    /**\n     * Closes the transport.\n     *\n     * @package\n     */ close(fn) {\n        if (\"closed\" === this.readyState || \"closing\" === this.readyState) return;\n        this.readyState = \"closing\";\n        this.doClose(fn || noop);\n    }\n    /**\n     * Called with a transport error.\n     *\n     * @param {String} msg - message error\n     * @param {Object} desc - error description\n     * @protected\n     */ onError(msg, desc) {\n        if (this.listeners(\"error\").length) {\n            const err = new Error(msg);\n            // @ts-ignore\n            err.type = \"TransportError\";\n            // @ts-ignore\n            err.description = desc;\n            this.emit(\"error\", err);\n        } else {\n            debug(\"ignored transport error %s (%s)\", msg, desc);\n        }\n    }\n    /**\n     * Called with parsed out a packets from the data stream.\n     *\n     * @param {Object} packet\n     * @protected\n     */ onPacket(packet) {\n        this.emit(\"packet\", packet);\n    }\n    /**\n     * Called with the encoded packet data.\n     *\n     * @param {String} data\n     * @protected\n     */ onData(data) {\n        this.onPacket(this.parser.decodePacket(data));\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @protected\n     */ onClose() {\n        this.readyState = \"closed\";\n        this.emit(\"close\");\n    }\n}\nexports.Transport = Transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxrRkFBa0I7QUFDNUMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzdDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1JLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsU0FBU0MsUUFBUztBQUNsQixNQUFNUixrQkFBa0JDLFNBQVNRLFlBQVk7SUFDekMsSUFBSUMsYUFBYTtRQUNiLE9BQU8sSUFBSSxDQUFDQyxXQUFXO0lBQzNCO0lBQ0EsSUFBSUQsV0FBV0UsS0FBSyxFQUFFO1FBQ2xCTixNQUFNLHlDQUF5QyxJQUFJLENBQUNLLFdBQVcsRUFBRUMsT0FBTyxJQUFJLENBQUNDLElBQUk7UUFDakYsSUFBSSxDQUFDRixXQUFXLEdBQUdDO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNERSxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNMLFdBQVcsR0FBRztRQUNuQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNNLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsR0FBR0gsSUFBSUksTUFBTSxDQUFDQyxHQUFHLEtBQUssTUFBTSxJQUFJLEdBQUcsMEJBQTBCO1FBQzFFLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0gsUUFBUSxLQUFLLElBQUlmLFlBQVlDO1FBQ2hELElBQUksQ0FBQ2tCLGNBQWMsR0FBRyxDQUFFUCxDQUFBQSxJQUFJSSxNQUFNLElBQUlKLElBQUlJLE1BQU0sQ0FBQ0ksR0FBRztJQUN4RDtJQUNBOzs7O0tBSUMsR0FDREMsVUFBVTtRQUNOLElBQUksQ0FBQ1AsU0FBUyxHQUFHO0lBQ3JCO0lBQ0E7Ozs7O0tBS0MsR0FDRFEsVUFBVVYsR0FBRyxFQUFFLENBQUU7SUFDakI7Ozs7S0FJQyxHQUNEVyxNQUFNQyxFQUFFLEVBQUU7UUFDTixJQUFJLGFBQWEsSUFBSSxDQUFDakIsVUFBVSxJQUFJLGNBQWMsSUFBSSxDQUFDQSxVQUFVLEVBQzdEO1FBQ0osSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDa0IsT0FBTyxDQUFDRCxNQUFNbkI7SUFDdkI7SUFDQTs7Ozs7O0tBTUMsR0FDRHFCLFFBQVFDLEdBQUcsRUFBRUMsSUFBSSxFQUFFO1FBQ2YsSUFBSSxJQUFJLENBQUNDLFNBQVMsQ0FBQyxTQUFTQyxNQUFNLEVBQUU7WUFDaEMsTUFBTUMsTUFBTSxJQUFJQyxNQUFNTDtZQUN0QixhQUFhO1lBQ2JJLElBQUlFLElBQUksR0FBRztZQUNYLGFBQWE7WUFDYkYsSUFBSUcsV0FBVyxHQUFHTjtZQUNsQixJQUFJLENBQUNPLElBQUksQ0FBQyxTQUFTSjtRQUN2QixPQUNLO1lBQ0Q1QixNQUFNLG1DQUFtQ3dCLEtBQUtDO1FBQ2xEO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEUSxTQUFTQyxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUNGLElBQUksQ0FBQyxVQUFVRTtJQUN4QjtJQUNBOzs7OztLQUtDLEdBQ0RDLE9BQU9DLElBQUksRUFBRTtRQUNULElBQUksQ0FBQ0gsUUFBUSxDQUFDLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ3NCLFlBQVksQ0FBQ0Q7SUFDM0M7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVU7UUFDTixJQUFJLENBQUNsQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDNEIsSUFBSSxDQUFDO0lBQ2Q7QUFDSjtBQUNBeEMsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0LmpzPzM3OTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zcG9ydCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHBhcnNlcl92NCA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuY29uc3QgcGFyc2VyX3YzID0gcmVxdWlyZShcIi4vcGFyc2VyLXYzL2luZGV4XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6dHJhbnNwb3J0XCIpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gICAgfVxuICAgIHNldCByZWFkeVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGRlYnVnKFwicmVhZHlTdGF0ZSB1cGRhdGVkIGZyb20gJXMgdG8gJXMgKCVzKVwiLCB0aGlzLl9yZWFkeVN0YXRlLCBzdGF0ZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdHJhbnNwb3J0IGlzIGN1cnJlbnRseSByZWFkeSB0byBzZW5kIHBhY2tldHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHJhbnNwb3J0LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0cmFuc3BvcnQgaXMgZGlzY2FyZGVkIGFuZCBjYW4gYmUgc2FmZWx5IGNsb3NlZCAodXNlZCBkdXJpbmcgdXBncmFkZSkuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzY2FyZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSByZXEuX3F1ZXJ5LkVJTyA9PT0gXCI0XCIgPyA0IDogMzsgLy8gM3JkIHJldmlzaW9uIGJ5IGRlZmF1bHRcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB0aGlzLnByb3RvY29sID09PSA0ID8gcGFyc2VyX3Y0IDogcGFyc2VyX3YzO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gIShyZXEuX3F1ZXJ5ICYmIHJlcS5fcXVlcnkuYjY0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhZ3MgdGhlIHRyYW5zcG9ydCBhcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggYW4gaW5jb21pbmcgSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgb25SZXF1ZXN0KHJlcSkgeyB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNsb3NlKGZuKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zaW5nXCI7XG4gICAgICAgIHRoaXMuZG9DbG9zZShmbiB8fCBub29wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggYSB0cmFuc3BvcnQgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gbWVzc2FnZSBlcnJvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjIC0gZXJyb3IgZGVzY3JpcHRpb25cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25FcnJvcihtc2csIGRlc2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKFwiZXJyb3JcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVyci50eXBlID0gXCJUcmFuc3BvcnRFcnJvclwiO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yZWQgdHJhbnNwb3J0IGVycm9yICVzICglcylcIiwgbXNnLCBkZXNjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBwYXJzZWQgb3V0IGEgcGFja2V0cyBmcm9tIHRoZSBkYXRhIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCB0aGUgZW5jb2RlZCBwYWNrZXQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMub25QYWNrZXQodGhpcy5wYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHJhbnNwb3J0IiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwicGFyc2VyX3Y0IiwicGFyc2VyX3YzIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsIm5vb3AiLCJFdmVudEVtaXR0ZXIiLCJyZWFkeVN0YXRlIiwiX3JlYWR5U3RhdGUiLCJzdGF0ZSIsIm5hbWUiLCJjb25zdHJ1Y3RvciIsInJlcSIsIndyaXRhYmxlIiwiZGlzY2FyZGVkIiwicHJvdG9jb2wiLCJfcXVlcnkiLCJFSU8iLCJwYXJzZXIiLCJzdXBwb3J0c0JpbmFyeSIsImI2NCIsImRpc2NhcmQiLCJvblJlcXVlc3QiLCJjbG9zZSIsImZuIiwiZG9DbG9zZSIsIm9uRXJyb3IiLCJtc2ciLCJkZXNjIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiZXJyIiwiRXJyb3IiLCJ0eXBlIiwiZGVzY3JpcHRpb24iLCJlbWl0Iiwib25QYWNrZXQiLCJwYWNrZXQiLCJvbkRhdGEiLCJkYXRhIiwiZGVjb2RlUGFja2V0Iiwib25DbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports-uws/polling.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js\");\nexports[\"default\"] = {\n    polling: polling_1.Polling,\n    websocket: websocket_1.WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFlBQVlDLG1CQUFPQSxDQUFDLGlGQUFXO0FBQ3JDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLHFGQUFhO0FBQ3pDSCxrQkFBZSxHQUFHO0lBQ2RNLFNBQVNKLFVBQVVLLE9BQU87SUFDMUJDLFdBQVdKLFlBQVlLLFNBQVM7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzLXV3cy9pbmRleC5qcz8xNmE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcG9sbGluZ18xID0gcmVxdWlyZShcIi4vcG9sbGluZ1wiKTtcbmNvbnN0IHdlYnNvY2tldF8xID0gcmVxdWlyZShcIi4vd2Vic29ja2V0XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIHBvbGxpbmc6IHBvbGxpbmdfMS5Qb2xsaW5nLFxuICAgIHdlYnNvY2tldDogd2Vic29ja2V0XzEuV2ViU29ja2V0LFxufTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBvbGxpbmdfMSIsInJlcXVpcmUiLCJ3ZWJzb2NrZXRfMSIsImRlZmF1bHQiLCJwb2xsaW5nIiwiUG9sbGluZyIsIndlYnNvY2tldCIsIldlYlNvY2tldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/polling.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/polling.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */ constructor(req){\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param req\n     *\n     * @private\n     */ onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (req.getMethod() === \"get\") {\n            this.onPollRequest(req, res);\n        } else if (req.getMethod() === \"post\") {\n            this.onDataRequest(req, res);\n        } else {\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */ onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = ()=>{\n            this.writable = false;\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = ()=>{\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        res.onAborted(onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */ onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        const expectedContentLength = Number(req.headers[\"content-length\"]);\n        if (!expectedContentLength) {\n            this.onError(\"content-length header required\");\n            res.writeStatus(\"411 Length Required\").end();\n            return;\n        }\n        if (expectedContentLength > this.maxHttpBufferSize) {\n            this.onError(\"payload too large\");\n            res.writeStatus(\"413 Payload Too Large\").end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let buffer;\n        let offset = 0;\n        const headers = {\n            // text/html is required instead of text/plain to avoid an\n            // unwanted download dialog on certain user-agents (GH-43)\n            \"Content-Type\": \"text/html\"\n        };\n        this.headers(req, headers);\n        for(let key in headers){\n            res.writeHeader(key, String(headers[key]));\n        }\n        const onEnd = (buffer)=>{\n            this.onData(buffer.toString());\n            this.onDataRequestCleanup();\n            res.cork(()=>{\n                res.end(\"ok\");\n            });\n        };\n        res.onAborted(()=>{\n            this.onDataRequestCleanup();\n            this.onError(\"data request connection closed prematurely\");\n        });\n        res.onData((arrayBuffer, isLast)=>{\n            const totalLength = offset + arrayBuffer.byteLength;\n            if (totalLength > expectedContentLength) {\n                this.onError(\"content-length mismatch\");\n                res.close(); // calls onAborted\n                return;\n            }\n            if (!buffer) {\n                if (isLast) {\n                    onEnd(Buffer.from(arrayBuffer));\n                    return;\n                }\n                buffer = Buffer.allocUnsafe(expectedContentLength);\n            }\n            Buffer.from(arrayBuffer).copy(buffer, offset);\n            if (isLast) {\n                if (totalLength != expectedContentLength) {\n                    this.onError(\"content-length mismatch\");\n                    res.writeStatus(\"400 Content-Length Mismatch\").end();\n                    this.onDataRequestCleanup();\n                    return;\n                }\n                onEnd(buffer);\n                return;\n            }\n            offset = totalLength;\n        });\n    }\n    /**\n     * Cleanup request.\n     *\n     * @private\n     */ onDataRequestCleanup() {\n        this.dataReq = this.dataRes = null;\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @private\n     */ onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet)=>{\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        } else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */ onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @private\n     */ send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({\n                type: \"close\"\n            });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data)=>{\n            const compress = packets.some((packet)=>{\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, {\n                compress\n            });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        } else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */ write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, ()=>{\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @private\n     */ doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = (data)=>{\n            this.headers(this.req, headers);\n            this.res.cork(()=>{\n                Object.keys(headers).forEach((key)=>{\n                    this.res.writeHeader(key, String(headers[key]));\n                });\n                this.res.end(data);\n            });\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\n            \"gzip\",\n            \"deflate\"\n        ]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data)=>{\n            if (err) {\n                this.res.writeStatus(\"500 Internal Server Error\");\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */ compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function(chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        }).on(\"end\", function() {\n            callback(null, Buffer.concat(buffers, nread));\n        }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        const onClose = ()=>{\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([\n                {\n                    type: \"close\"\n                }\n            ]);\n            onClose();\n        } else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        } else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param req - request\n     * @param {Object} extra headers\n     * @private\n     */ headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3BvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHNEQUFTO0FBQ2pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1JLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMscUJBQXFCO0lBQ3ZCQyxNQUFNTixPQUFPTyxVQUFVO0lBQ3ZCQyxTQUFTUixPQUFPUyxhQUFhO0FBQ2pDO0FBQ0EsTUFBTVosZ0JBQWdCQyxZQUFZWSxTQUFTO0lBQ3ZDOztLQUVDLEdBQ0RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFlBQVksR0FBRyxLQUFLO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7Ozs7OztLQU1DLEdBQ0RDLFVBQVVILEdBQUcsRUFBRTtRQUNYLE1BQU1JLE1BQU1KLElBQUlJLEdBQUc7UUFDbkIsdUhBQXVIO1FBQ3ZISixJQUFJSSxHQUFHLEdBQUc7UUFDVixJQUFJSixJQUFJSyxTQUFTLE9BQU8sT0FBTztZQUMzQixJQUFJLENBQUNDLGFBQWEsQ0FBQ04sS0FBS0k7UUFDNUIsT0FDSyxJQUFJSixJQUFJSyxTQUFTLE9BQU8sUUFBUTtZQUNqQyxJQUFJLENBQUNFLGFBQWEsQ0FBQ1AsS0FBS0k7UUFDNUIsT0FDSztZQUNEQSxJQUFJSSxXQUFXLENBQUM7WUFDaEJKLElBQUlLLEdBQUc7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNE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S3BGLElBQUlzQixPQUFPLENBQUMsYUFBYTtRQUNwQyxJQUFJOEQsTUFBTyxFQUFDQSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDRCxHQUFHQyxPQUFPLENBQUMsV0FBVSxHQUFJO1lBQ3pEL0QsT0FBTyxDQUFDLG1CQUFtQixHQUFHO1FBQ2xDO1FBQ0FBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztRQUMzQixJQUFJLENBQUNQLElBQUksQ0FBQyxXQUFXTyxTQUFTdEI7UUFDOUIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBdkMsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3BvbGxpbmcuanM/NzJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9sbGluZyA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6cG9sbGluZ1wiKTtcbmNvbnN0IGNvbXByZXNzaW9uTWV0aG9kcyA9IHtcbiAgICBnemlwOiB6bGliXzEuY3JlYXRlR3ppcCxcbiAgICBkZWZsYXRlOiB6bGliXzEuY3JlYXRlRGVmbGF0ZSxcbn07XG5jbGFzcyBQb2xsaW5nIGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBIVFRQIHBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvblJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVxLnJlcztcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIFNlcnZlclJlc3BvbnNlIG9iamVjdCAoYXMgdGhlIGZpcnN0IHJlcXVlc3Qgb2YgdGhlIHNlc3Npb24gaXMga2VwdCBpbiBtZW1vcnkgYnkgZGVmYXVsdClcbiAgICAgICAgcmVxLnJlcyA9IG51bGw7XG4gICAgICAgIGlmIChyZXEuZ2V0TWV0aG9kKCkgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMub25Qb2xsUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxLmdldE1ldGhvZCgpID09PSBcInBvc3RcIikge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3QgYXdhaXRpbmcgZm9yIHVzIHRvIHNlbmQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25Qb2xsUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVxdWVzdCBvdmVybGFwXCIpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLnJlcywgJy5yZXEgYW5kIC5yZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicG9sbCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxID0gdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXEuY2xlYW51cCA9IGNsZWFudXA7XG4gICAgICAgIHJlcy5vbkFib3J0ZWQob25DbG9zZSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgd3JpdGFibGUgYnV0IGhhZCBhIHBlbmRpbmcgY2xvc2UsIHRyaWdnZXIgYW4gZW1wdHkgc2VuZFxuICAgICAgICBpZiAodGhpcy53cml0YWJsZSAmJiB0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyaWdnZXJpbmcgZW1wdHkgc2VuZCB0byBhcHBlbmQgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLmRhdGFSZXMsICcuZGF0YVJlcSBhbmQgLmRhdGFSZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3Qgb3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb250ZW50TGVuZ3RoID0gTnVtYmVyKHJlcS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0pO1xuICAgICAgICBpZiAoIWV4cGVjdGVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggaGVhZGVyIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNDExIExlbmd0aCBSZXF1aXJlZFwiKS5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWRDb250ZW50TGVuZ3RoID4gdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicGF5bG9hZCB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI0MTMgUGF5bG9hZCBUb28gTGFyZ2VcIikuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNCaW5hcnkgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiID09PSByZXEuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgaWYgKGlzQmluYXJ5ICYmIHRoaXMucHJvdG9jb2wgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUmVxID0gcmVxO1xuICAgICAgICB0aGlzLmRhdGFSZXMgPSByZXM7XG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gdGV4dC9odG1sIGlzIHJlcXVpcmVkIGluc3RlYWQgb2YgdGV4dC9wbGFpbiB0byBhdm9pZCBhblxuICAgICAgICAgICAgLy8gdW53YW50ZWQgZG93bmxvYWQgZGlhbG9nIG9uIGNlcnRhaW4gdXNlci1hZ2VudHMgKEdILTQzKVxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oZWFkZXJzKHJlcSwgaGVhZGVycyk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoa2V5LCBTdHJpbmcoaGVhZGVyc1trZXldKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25FbmQgPSAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShidWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICByZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzLmVuZChcIm9rXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcy5vbkFib3J0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLm9uRGF0YSgoYXJyYXlCdWZmZXIsIGlzTGFzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSBvZmZzZXQgKyBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gZXhwZWN0ZWRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgcmVzLmNsb3NlKCk7IC8vIGNhbGxzIG9uQWJvcnRlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShleHBlY3RlZENvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aCAhPSBleHBlY3RlZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjQwMCBDb250ZW50LUxlbmd0aCBNaXNtYXRjaFwiKS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gdG90YWxMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnVwIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3RDbGVhbnVwKCkge1xuICAgICAgICB0aGlzLmRhdGFSZXEgPSB0aGlzLmRhdGFSZXMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGluY29taW5nIGRhdGEgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkIHBheWxvYWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGRlYnVnKCdyZWNlaXZlZCBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAocGFja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHhociBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvbkNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gY2xvc2UgcGVuZGluZyBwb2xsIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25DbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFwcGVuZGluZyBjbG9zZSBwYWNrZXQgdG8gcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIHBhY2tldHMucHVzaCh7IHR5cGU6IFwiY2xvc2VcIiB9KTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvV3JpdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSBwYWNrZXRzLnNvbWUoKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgd3JpdGUoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgdGhpcy5kb1dyaXRlKGRhdGEsIG9wdGlvbnMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IFVURi04IGlzIHJlcXVpcmVkIGZvciBwYWdlcyBub3Qgc2VydmVkIHVuZGVyIHV0ZlxuICAgICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGlzU3RyaW5nXG4gICAgICAgICAgICA/IFwidGV4dC9wbGFpbjsgY2hhcnNldD1VVEYtOFwiXG4gICAgICAgICAgICA6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnModGhpcy5yZXEsIGhlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5yZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgU3RyaW5nKGhlYWRlcnNba2V5XSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLmVuZChkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmh0dHBDb21wcmVzc2lvbiB8fCAhb3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBpc1N0cmluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCB0aGlzLmh0dHBDb21wcmVzc2lvbi50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHRoaXMucmVxKS5lbmNvZGluZ3MoW1wiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXByZXNzZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRlYnVnKFwiY29tcHJlc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgbGV0IG5yZWFkID0gMDtcbiAgICAgICAgY29tcHJlc3Npb25NZXRob2RzW2VuY29kaW5nXSh0aGlzLmh0dHBDb21wcmVzc2lvbilcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmVuZChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvQ2xvc2UoZm4pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nXCIpO1xuICAgICAgICBsZXQgY2xvc2VUaW1lb3V0VGltZXI7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgd3JpdGFibGUgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpc2NhcmRlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZGlzY2FyZGVkIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgbm90IHdyaXRhYmxlIC0gYnVmZmVyaW5nIG9yZGVybHkgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gb25DbG9zZTtcbiAgICAgICAgICAgIGNsb3NlVGltZW91dFRpbWVyID0gc2V0VGltZW91dChvbkNsb3NlLCB0aGlzLmNsb3NlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWFkZXJzIGZvciBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcSAtIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgaGVhZGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaGVhZGVycyhyZXEsIGhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIC8vIHByZXZlbnQgWFNTIHdhcm5pbmdzIG9uIElFXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFybkJvb3N0L3NvY2tldC5pby9wdWxsLzEzMzNcbiAgICAgICAgY29uc3QgdWEgPSByZXEuaGVhZGVyc1tcInVzZXItYWdlbnRcIl07XG4gICAgICAgIGlmICh1YSAmJiAofnVhLmluZGV4T2YoXCI7TVNJRVwiKSB8fCB+dWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpKSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtWFNTLVByb3RlY3Rpb25cIl0gPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IFwibm8tc3RvcmVcIjtcbiAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmcgPSBQb2xsaW5nO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9sbGluZyIsInRyYW5zcG9ydF8xIiwicmVxdWlyZSIsInpsaWJfMSIsImFjY2VwdHMiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiY29tcHJlc3Npb25NZXRob2RzIiwiZ3ppcCIsImNyZWF0ZUd6aXAiLCJkZWZsYXRlIiwiY3JlYXRlRGVmbGF0ZSIsIlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwicmVxIiwiY2xvc2VUaW1lb3V0IiwibmFtZSIsIm9uUmVxdWVzdCIsInJlcyIsImdldE1ldGhvZCIsIm9uUG9sbFJlcXVlc3QiLCJvbkRhdGFSZXF1ZXN0Iiwid3JpdGVTdGF0dXMiLCJlbmQiLCJvbkVycm9yIiwib25DbG9zZSIsIndyaXRhYmxlIiwiY2xlYW51cCIsIm9uQWJvcnRlZCIsImVtaXQiLCJzaG91bGRDbG9zZSIsInNlbmQiLCJ0eXBlIiwiZGF0YVJlcSIsImV4cGVjdGVkQ29udGVudExlbmd0aCIsIk51bWJlciIsImhlYWRlcnMiLCJtYXhIdHRwQnVmZmVyU2l6ZSIsImlzQmluYXJ5IiwicHJvdG9jb2wiLCJkYXRhUmVzIiwiYnVmZmVyIiwib2Zmc2V0Iiwia2V5Iiwid3JpdGVIZWFkZXIiLCJTdHJpbmciLCJvbkVuZCIsIm9uRGF0YSIsInRvU3RyaW5nIiwib25EYXRhUmVxdWVzdENsZWFudXAiLCJjb3JrIiwiYXJyYXlCdWZmZXIiLCJpc0xhc3QiLCJ0b3RhbExlbmd0aCIsImJ5dGVMZW5ndGgiLCJjbG9zZSIsIkJ1ZmZlciIsImZyb20iLCJhbGxvY1Vuc2FmZSIsImNvcHkiLCJkYXRhIiwiY2FsbGJhY2siLCJwYWNrZXQiLCJvblBhY2tldCIsInBhcnNlciIsImRlY29kZVBheWxvYWQiLCJmb3JFYWNoIiwicGFja2V0cyIsInB1c2giLCJkb1dyaXRlIiwiY29tcHJlc3MiLCJzb21lIiwib3B0aW9ucyIsIndyaXRlIiwiZW5jb2RlUGF5bG9hZCIsInN1cHBvcnRzQmluYXJ5IiwiaXNTdHJpbmciLCJjb250ZW50VHlwZSIsInJlc3BvbmQiLCJrZXlzIiwiaHR0cENvbXByZXNzaW9uIiwibGVuIiwibGVuZ3RoIiwidGhyZXNob2xkIiwiZW5jb2RpbmciLCJlbmNvZGluZ3MiLCJlcnIiLCJidWZmZXJzIiwibnJlYWQiLCJvbiIsImNodW5rIiwiY29uY2F0IiwiZG9DbG9zZSIsImZuIiwiY2xvc2VUaW1lb3V0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJkaXNjYXJkZWQiLCJzZXRUaW1lb3V0IiwidWEiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/websocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param req\n     */ constructor(req){\n        super(req);\n        this.writable = false;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */ get handlesUpgrades() {\n        return true;\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Array} packets\n     * @private\n     */ send(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            const send = (data)=>{\n                const isBinary = typeof data !== \"string\";\n                const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;\n                debug('writing \"%s\"', data);\n                this.socket.send(data, isBinary, compress);\n                if (isLast) {\n                    this.emit(\"drain\");\n                    this.writable = true;\n                    this.emit(\"ready\");\n                }\n            };\n            if (packet.options && typeof packet.options.wsPreEncoded === \"string\") {\n                send(packet.options.wsPreEncoded);\n            } else {\n                this.parser.encodePacket(packet, this.supportsBinary, send);\n            }\n        }\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        fn && fn();\n        // call fn first since socket.end() immediately emits a \"close\" event\n        this.socket.end();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyx1RUFBYztBQUMxQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQixNQUFNRSxRQUFRLENBQUMsR0FBR0QsUUFBUUUsT0FBTyxFQUFFO0FBQ25DLE1BQU1MLGtCQUFrQkMsWUFBWUssU0FBUztJQUN6Qzs7OztLQUlDLEdBQ0RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0E7Ozs7O0tBS0MsR0FDREMsS0FBS0MsT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDTCxRQUFRLEdBQUc7UUFDaEIsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7WUFDekIsTUFBTUcsU0FBU0gsSUFBSSxNQUFNRCxRQUFRRSxNQUFNO1lBQ3ZDLE1BQU1ILE9BQU8sQ0FBQ007Z0JBQ1YsTUFBTUMsV0FBVyxPQUFPRCxTQUFTO2dCQUNqQyxNQUFNRSxXQUFXLElBQUksQ0FBQ1gsaUJBQWlCLElBQ25DWSxPQUFPQyxVQUFVLENBQUNKLFFBQVEsSUFBSSxDQUFDVCxpQkFBaUIsQ0FBQ2MsU0FBUztnQkFDOURwQixNQUFNLGdCQUFnQmU7Z0JBQ3RCLElBQUksQ0FBQ00sTUFBTSxDQUFDWixJQUFJLENBQUNNLE1BQU1DLFVBQVVDO2dCQUNqQyxJQUFJSCxRQUFRO29CQUNSLElBQUksQ0FBQ1EsSUFBSSxDQUFDO29CQUNWLElBQUksQ0FBQ2pCLFFBQVEsR0FBRztvQkFDaEIsSUFBSSxDQUFDaUIsSUFBSSxDQUFDO2dCQUNkO1lBQ0o7WUFDQSxJQUFJVCxPQUFPVSxPQUFPLElBQUksT0FBT1YsT0FBT1UsT0FBTyxDQUFDQyxZQUFZLEtBQUssVUFBVTtnQkFDbkVmLEtBQUtJLE9BQU9VLE9BQU8sQ0FBQ0MsWUFBWTtZQUNwQyxPQUNLO2dCQUNELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxZQUFZLENBQUNiLFFBQVEsSUFBSSxDQUFDYyxjQUFjLEVBQUVsQjtZQUMxRDtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RtQixRQUFRQyxFQUFFLEVBQUU7UUFDUjdCLE1BQU07UUFDTjZCLE1BQU1BO1FBQ04scUVBQXFFO1FBQ3JFLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxHQUFHO0lBQ25CO0FBQ0o7QUFDQXBDLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcz9hMzg1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJTb2NrZXQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp3c1wiKTtcbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IHRyYW5zcG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2ZXJ0aXNlIHVwZ3JhZGUgc3VwcG9ydC5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlc1VwZ3JhZGVzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XG4gICAgICAgICAgICBjb25zdCBpc0xhc3QgPSBpICsgMSA9PT0gcGFja2V0cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBzZW5kID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzID0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA+IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSwgaXNCaW5hcnksIGNvbXByZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucyAmJiB0eXBlb2YgcGFja2V0Lm9wdGlvbnMud3NQcmVFbmNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc2VuZChwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgc2VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvQ2xvc2UoZm4pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nXCIpO1xuICAgICAgICBmbiAmJiBmbigpO1xuICAgICAgICAvLyBjYWxsIGZuIGZpcnN0IHNpbmNlIHNvY2tldC5lbmQoKSBpbW1lZGlhdGVseSBlbWl0cyBhIFwiY2xvc2VcIiBldmVudFxuICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLldlYlNvY2tldCA9IFdlYlNvY2tldDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldlYlNvY2tldCIsInRyYW5zcG9ydF8xIiwicmVxdWlyZSIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJUcmFuc3BvcnQiLCJjb25zdHJ1Y3RvciIsInJlcSIsIndyaXRhYmxlIiwicGVyTWVzc2FnZURlZmxhdGUiLCJuYW1lIiwiaGFuZGxlc1VwZ3JhZGVzIiwic2VuZCIsInBhY2tldHMiLCJpIiwibGVuZ3RoIiwicGFja2V0IiwiaXNMYXN0IiwiZGF0YSIsImlzQmluYXJ5IiwiY29tcHJlc3MiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwidGhyZXNob2xkIiwic29ja2V0IiwiZW1pdCIsIm9wdGlvbnMiLCJ3c1ByZUVuY29kZWQiLCJwYXJzZXIiLCJlbmNvZGVQYWNrZXQiLCJzdXBwb3J0c0JpbmFyeSIsImRvQ2xvc2UiLCJmbiIsImVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io/build/transports/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports/polling.js\");\nconst polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ \"(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/engine.io/build/transports/websocket.js\");\nconst webtransport_1 = __webpack_require__(/*! ./webtransport */ \"(rsc)/./node_modules/engine.io/build/transports/webtransport.js\");\nexports[\"default\"] = {\n    polling: polling,\n    websocket: websocket_1.WebSocket,\n    webtransport: webtransport_1.WebTransport\n};\n/**\n * Polling polymorphic constructor.\n */ function polling(req) {\n    if (\"string\" === typeof req._query.j) {\n        return new polling_jsonp_1.JSONP(req);\n    } else {\n        return new polling_1.Polling(req);\n    }\n}\npolling.upgradesTo = [\n    \"websocket\",\n    \"webtransport\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsWUFBWUMsbUJBQU9BLENBQUMsNkVBQVc7QUFDckMsTUFBTUMsa0JBQWtCRCxtQkFBT0EsQ0FBQyx5RkFBaUI7QUFDakQsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsaUZBQWE7QUFDekMsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQyx1RkFBZ0I7QUFDL0NILGtCQUFlLEdBQUc7SUFDZFEsU0FBU0E7SUFDVEMsV0FBV0osWUFBWUssU0FBUztJQUNoQ0MsY0FBY0wsZUFBZU0sWUFBWTtBQUM3QztBQUNBOztDQUVDLEdBQ0QsU0FBU0osUUFBUUssR0FBRztJQUNoQixJQUFJLGFBQWEsT0FBT0EsSUFBSUMsTUFBTSxDQUFDQyxDQUFDLEVBQUU7UUFDbEMsT0FBTyxJQUFJWCxnQkFBZ0JZLEtBQUssQ0FBQ0g7SUFDckMsT0FDSztRQUNELE9BQU8sSUFBSVgsVUFBVWUsT0FBTyxDQUFDSjtJQUNqQztBQUNKO0FBQ0FMLFFBQVFVLFVBQVUsR0FBRztJQUFDO0lBQWE7Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvaW5kZXguanM/MDc1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBvbGxpbmdfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmdcIik7XG5jb25zdCBwb2xsaW5nX2pzb25wXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nLWpzb25wXCIpO1xuY29uc3Qgd2Vic29ja2V0XzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXRcIik7XG5jb25zdCB3ZWJ0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3dlYnRyYW5zcG9ydFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBwb2xsaW5nOiBwb2xsaW5nLFxuICAgIHdlYnNvY2tldDogd2Vic29ja2V0XzEuV2ViU29ja2V0LFxuICAgIHdlYnRyYW5zcG9ydDogd2VidHJhbnNwb3J0XzEuV2ViVHJhbnNwb3J0LFxufTtcbi8qKlxuICogUG9sbGluZyBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gcG9sbGluZyhyZXEpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlcS5fcXVlcnkuaikge1xuICAgICAgICByZXR1cm4gbmV3IHBvbGxpbmdfanNvbnBfMS5KU09OUChyZXEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb2xsaW5nXzEuUG9sbGluZyhyZXEpO1xuICAgIH1cbn1cbnBvbGxpbmcudXBncmFkZXNUbyA9IFtcIndlYnNvY2tldFwiLCBcIndlYnRyYW5zcG9ydFwiXTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBvbGxpbmdfMSIsInJlcXVpcmUiLCJwb2xsaW5nX2pzb25wXzEiLCJ3ZWJzb2NrZXRfMSIsIndlYnRyYW5zcG9ydF8xIiwiZGVmYXVsdCIsInBvbGxpbmciLCJ3ZWJzb2NrZXQiLCJXZWJTb2NrZXQiLCJ3ZWJ0cmFuc3BvcnQiLCJXZWJUcmFuc3BvcnQiLCJyZXEiLCJfcXVlcnkiLCJqIiwiSlNPTlAiLCJQb2xsaW5nIiwidXBncmFkZXNUbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JSONP = void 0;\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports/polling.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst rDoubleSlashes = /\\\\\\\\n/g;\nconst rSlashes = /(\\\\)?\\\\n/g;\nclass JSONP extends polling_1.Polling {\n    /**\n     * JSON-P polling transport.\n     */ constructor(req){\n        super(req);\n        this.head = \"___eio[\" + (req._query.j || \"\").replace(/[^0-9]/g, \"\") + \"](\";\n        this.foot = \");\";\n    }\n    onData(data) {\n        // we leverage the qs module so that we get built-in DoS protection\n        // and the fast alternative to decodeURIComponent\n        data = qs.parse(data).d;\n        if (\"string\" === typeof data) {\n            // client will send already escaped newlines as \\\\\\\\n and newlines as \\\\n\n            // \\\\n must be replaced with \\n and \\\\\\\\n with \\\\n\n            data = data.replace(rSlashes, function(match, slashes) {\n                return slashes ? match : \"\\n\";\n            });\n            super.onData(data.replace(rDoubleSlashes, \"\\\\n\"));\n        }\n    }\n    doWrite(data, options, callback) {\n        // we must output valid javascript, not valid json\n        // see: http://timelessrepo.com/json-isnt-a-javascript-subset\n        const js = JSON.stringify(data).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n        // prepare response\n        data = this.head + js + this.foot;\n        super.doWrite(data, options, callback);\n    }\n}\nexports.JSONP = JSONP;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHLEtBQUs7QUFDckIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsNkVBQVc7QUFDckMsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaEMsTUFBTUUsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUwsY0FBY0MsVUFBVUssT0FBTztJQUNqQzs7S0FFQyxHQUNEQyxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUcsWUFBWSxDQUFDRCxJQUFJRSxNQUFNLENBQUNDLENBQUMsSUFBSSxFQUFDLEVBQUdDLE9BQU8sQ0FBQyxXQUFXLE1BQU07UUFDdEUsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7SUFDQUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1QsbUVBQW1FO1FBQ25FLGlEQUFpRDtRQUNqREEsT0FBT1osR0FBR2EsS0FBSyxDQUFDRCxNQUFNRSxDQUFDO1FBQ3ZCLElBQUksYUFBYSxPQUFPRixNQUFNO1lBQzFCLHlFQUF5RTtZQUN6RSxrREFBa0Q7WUFDbERBLE9BQU9BLEtBQUtILE9BQU8sQ0FBQ1AsVUFBVSxTQUFVYSxLQUFLLEVBQUVDLE9BQU87Z0JBQ2xELE9BQU9BLFVBQVVELFFBQVE7WUFDN0I7WUFDQSxLQUFLLENBQUNKLE9BQU9DLEtBQUtILE9BQU8sQ0FBQ1IsZ0JBQWdCO1FBQzlDO0lBQ0o7SUFDQWdCLFFBQVFMLElBQUksRUFBRU0sT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDN0Isa0RBQWtEO1FBQ2xELDZEQUE2RDtRQUM3RCxNQUFNQyxLQUFLQyxLQUFLQyxTQUFTLENBQUNWLE1BQ3JCSCxPQUFPLENBQUMsV0FBVyxXQUNuQkEsT0FBTyxDQUFDLFdBQVc7UUFDeEIsbUJBQW1CO1FBQ25CRyxPQUFPLElBQUksQ0FBQ04sSUFBSSxHQUFHYyxLQUFLLElBQUksQ0FBQ1YsSUFBSTtRQUNqQyxLQUFLLENBQUNPLFFBQVFMLE1BQU1NLFNBQVNDO0lBQ2pDO0FBQ0o7QUFDQXhCLGFBQWEsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanM/ZDU0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSlNPTlAgPSB2b2lkIDA7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3QgcXMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCByRG91YmxlU2xhc2hlcyA9IC9cXFxcXFxcXG4vZztcbmNvbnN0IHJTbGFzaGVzID0gLyhcXFxcKT9cXFxcbi9nO1xuY2xhc3MgSlNPTlAgZXh0ZW5kcyBwb2xsaW5nXzEuUG9sbGluZyB7XG4gICAgLyoqXG4gICAgICogSlNPTi1QIHBvbGxpbmcgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLmhlYWQgPSBcIl9fX2Vpb1tcIiArIChyZXEuX3F1ZXJ5LmogfHwgXCJcIikucmVwbGFjZSgvW14wLTldL2csIFwiXCIpICsgXCJdKFwiO1xuICAgICAgICB0aGlzLmZvb3QgPSBcIik7XCI7XG4gICAgfVxuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIHdlIGxldmVyYWdlIHRoZSBxcyBtb2R1bGUgc28gdGhhdCB3ZSBnZXQgYnVpbHQtaW4gRG9TIHByb3RlY3Rpb25cbiAgICAgICAgLy8gYW5kIHRoZSBmYXN0IGFsdGVybmF0aXZlIHRvIGRlY29kZVVSSUNvbXBvbmVudFxuICAgICAgICBkYXRhID0gcXMucGFyc2UoZGF0YSkuZDtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICAvLyBjbGllbnQgd2lsbCBzZW5kIGFscmVhZHkgZXNjYXBlZCBuZXdsaW5lcyBhcyBcXFxcXFxcXG4gYW5kIG5ld2xpbmVzIGFzIFxcXFxuXG4gICAgICAgICAgICAvLyBcXFxcbiBtdXN0IGJlIHJlcGxhY2VkIHdpdGggXFxuIGFuZCBcXFxcXFxcXG4gd2l0aCBcXFxcblxuICAgICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShyU2xhc2hlcywgZnVuY3Rpb24gKG1hdGNoLCBzbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMgPyBtYXRjaCA6IFwiXFxuXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1cGVyLm9uRGF0YShkYXRhLnJlcGxhY2UockRvdWJsZVNsYXNoZXMsIFwiXFxcXG5cIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gd2UgbXVzdCBvdXRwdXQgdmFsaWQgamF2YXNjcmlwdCwgbm90IHZhbGlkIGpzb25cbiAgICAgICAgLy8gc2VlOiBodHRwOi8vdGltZWxlc3NyZXBvLmNvbS9qc29uLWlzbnQtYS1qYXZhc2NyaXB0LXN1YnNldFxuICAgICAgICBjb25zdCBqcyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG4gICAgICAgIC8vIHByZXBhcmUgcmVzcG9uc2VcbiAgICAgICAgZGF0YSA9IHRoaXMuaGVhZCArIGpzICsgdGhpcy5mb290O1xuICAgICAgICBzdXBlci5kb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLkpTT05QID0gSlNPTlA7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJKU09OUCIsInBvbGxpbmdfMSIsInJlcXVpcmUiLCJxcyIsInJEb3VibGVTbGFzaGVzIiwiclNsYXNoZXMiLCJQb2xsaW5nIiwiY29uc3RydWN0b3IiLCJyZXEiLCJoZWFkIiwiX3F1ZXJ5IiwiaiIsInJlcGxhY2UiLCJmb290Iiwib25EYXRhIiwiZGF0YSIsInBhcnNlIiwiZCIsIm1hdGNoIiwic2xhc2hlcyIsImRvV3JpdGUiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJqcyIsIkpTT04iLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/polling.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */ constructor(req){\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param {EngineRequest} req\n     * @package\n     */ onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (\"GET\" === req.method) {\n            this.onPollRequest(req, res);\n        } else if (\"POST\" === req.method) {\n            this.onDataRequest(req, res);\n        } else {\n            res.writeHead(500);\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */ onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = ()=>{\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = ()=>{\n            req.removeListener(\"close\", onClose);\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        req.on(\"close\", onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */ onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let chunks = isBinary ? Buffer.concat([]) : \"\";\n        const cleanup = ()=>{\n            req.removeListener(\"data\", onData);\n            req.removeListener(\"end\", onEnd);\n            req.removeListener(\"close\", onClose);\n            this.dataReq = this.dataRes = chunks = null;\n        };\n        const onClose = ()=>{\n            cleanup();\n            this.onError(\"data request connection closed prematurely\");\n        };\n        const onData = (data)=>{\n            let contentLength;\n            if (isBinary) {\n                chunks = Buffer.concat([\n                    chunks,\n                    data\n                ]);\n                contentLength = chunks.length;\n            } else {\n                chunks += data;\n                contentLength = Buffer.byteLength(chunks);\n            }\n            if (contentLength > this.maxHttpBufferSize) {\n                res.writeHead(413).end();\n                cleanup();\n            }\n        };\n        const onEnd = ()=>{\n            this.onData(chunks);\n            const headers = {\n                // text/html is required instead of text/plain to avoid an\n                // unwanted download dialog on certain user-agents (GH-43)\n                \"Content-Type\": \"text/html\",\n                \"Content-Length\": \"2\"\n            };\n            res.writeHead(200, this.headers(req, headers));\n            res.end(\"ok\");\n            cleanup();\n        };\n        req.on(\"close\", onClose);\n        if (!isBinary) req.setEncoding(\"utf8\");\n        req.on(\"data\", onData);\n        req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param data - encoded payload\n     * @protected\n     */ onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet)=>{\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        } else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */ onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n        super.onClose();\n    }\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({\n                type: \"close\"\n            });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data)=>{\n            const compress = packets.some((packet)=>{\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, {\n                compress\n            });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        } else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */ write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, ()=>{\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @protected\n     */ doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = (data)=>{\n            headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            this.res.writeHead(200, this.headers(this.req, headers));\n            this.res.end(data);\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\n            \"gzip\",\n            \"deflate\"\n        ]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data)=>{\n            if (err) {\n                this.res.writeHead(500);\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */ compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function(chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        }).on(\"end\", function() {\n            callback(null, Buffer.concat(buffers, nread));\n        }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        if (this.dataReq) {\n            debug(\"aborting ongoing data request\");\n            this.dataReq.destroy();\n        }\n        const onClose = ()=>{\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([\n                {\n                    type: \"close\"\n                }\n            ]);\n            onClose();\n        } else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        } else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} req\n     * @param {Object} headers - extra headers\n     * @private\n     */ headers(req, headers = {}) {\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMsdUVBQWM7QUFDMUMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsc0RBQVM7QUFDakMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsNkVBQU87QUFDL0IsTUFBTUksUUFBUSxDQUFDLEdBQUdELFFBQVFFLE9BQU8sRUFBRTtBQUNuQyxNQUFNQyxxQkFBcUI7SUFDdkJDLE1BQU1OLE9BQU9PLFVBQVU7SUFDdkJDLFNBQVNSLE9BQU9TLGFBQWE7QUFDakM7QUFDQSxNQUFNWixnQkFBZ0JDLFlBQVlZLFNBQVM7SUFDdkM7O0tBRUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUs7SUFDN0I7SUFDQTs7S0FFQyxHQUNELElBQUlDLE9BQU87UUFDUCxPQUFPO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEQyxVQUFVSCxHQUFHLEVBQUU7UUFDWCxNQUFNSSxNQUFNSixJQUFJSSxHQUFHO1FBQ25CLHVIQUF1SDtRQUN2SEosSUFBSUksR0FBRyxHQUFHO1FBQ1YsSUFBSSxVQUFVSixJQUFJSyxNQUFNLEVBQUU7WUFDdEIsSUFBSSxDQUFDQyxhQUFhLENBQUNOLEtBQUtJO1FBQzVCLE9BQ0ssSUFBSSxXQUFXSixJQUFJSyxNQUFNLEVBQUU7WUFDNUIsSUFBSSxDQUFDRSxhQUFhLENBQUNQLEtBQUtJO1FBQzVCLE9BQ0s7WUFDREEsSUFBSUksU0FBUyxDQUFDO1lBQ2RKLElBQUlLLEdBQUc7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNESCxjQUFj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LElBQUksQ0FBQzdDLE9BQU8sRUFBRTtZQUNkN0IsTUFBTTtZQUNOLElBQUksQ0FBQzZCLE9BQU8sQ0FBQzhDLE9BQU87UUFDeEI7UUFDQSxNQUFNdkQsVUFBVTtZQUNad0QsYUFBYUY7WUFDYkQ7WUFDQSxJQUFJLENBQUNyRCxPQUFPO1FBQ2hCO1FBQ0EsSUFBSSxJQUFJLENBQUNJLFFBQVEsRUFBRTtZQUNmeEIsTUFBTTtZQUNOLElBQUksQ0FBQzJCLElBQUksQ0FBQztnQkFBQztvQkFBRUMsTUFBTTtnQkFBUTthQUFFO1lBQzdCUjtRQUNKLE9BQ0ssSUFBSSxJQUFJLENBQUN5RCxTQUFTLEVBQUU7WUFDckI3RSxNQUFNO1lBQ05vQjtRQUNKLE9BQ0s7WUFDRHBCLE1BQU07WUFDTixJQUFJLENBQUMwQixXQUFXLEdBQUdOO1lBQ25Cc0Qsb0JBQW9CSSxXQUFXMUQsU0FBUyxJQUFJLENBQUNWLFlBQVk7UUFDN0Q7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEcUIsUUFBUXRCLEdBQUcsRUFBRXNCLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDdkIsNkJBQTZCO1FBQzdCLG9EQUFvRDtRQUNwRCxNQUFNZ0QsS0FBS3RFLElBQUlzQixPQUFPLENBQUMsYUFBYTtRQUNwQyxJQUFJZ0QsTUFBTyxFQUFDQSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDRCxHQUFHQyxPQUFPLENBQUMsV0FBVSxHQUFJO1lBQ3pEakQsT0FBTyxDQUFDLG1CQUFtQixHQUFHO1FBQ2xDO1FBQ0FBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztRQUMzQixJQUFJLENBQUNOLElBQUksQ0FBQyxXQUFXTSxTQUFTdEI7UUFDOUIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBdkMsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy5qcz9kNDdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBhY2NlcHRzID0gcmVxdWlyZShcImFjY2VwdHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTpwb2xsaW5nXCIpO1xuY29uc3QgY29tcHJlc3Npb25NZXRob2RzID0ge1xuICAgIGd6aXA6IHpsaWJfMS5jcmVhdGVHemlwLFxuICAgIGRlZmxhdGU6IHpsaWJfMS5jcmVhdGVEZWZsYXRlLFxufTtcbmNsYXNzIFBvbGxpbmcgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIEhUVFAgcG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy5jbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInBvbGxpbmdcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBvblJlcXVlc3QocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlcS5yZXM7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBTZXJ2ZXJSZXNwb25zZSBvYmplY3QgKGFzIHRoZSBmaXJzdCByZXF1ZXN0IG9mIHRoZSBzZXNzaW9uIGlzIGtlcHQgaW4gbWVtb3J5IGJ5IGRlZmF1bHQpXG4gICAgICAgIHJlcS5yZXMgPSBudWxsO1xuICAgICAgICBpZiAoXCJHRVRcIiA9PT0gcmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy5vblBvbGxSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcIlBPU1RcIiA9PT0gcmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCBhd2FpdGluZyBmb3IgdXMgdG8gc2VuZCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblBvbGxSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgZGVidWcoXCJyZXF1ZXN0IG92ZXJsYXBcIik7XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IHRoaXMucmVzLCAnLnJlcSBhbmQgLnJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcIm92ZXJsYXAgZnJvbSBjbGllbnRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDQwMCk7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZXR0aW5nIHJlcXVlc3RcIik7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInBvbGwgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgICAgIHRoaXMucmVxID0gdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXEuY2xlYW51cCA9IGNsZWFudXA7XG4gICAgICAgIHJlcS5vbihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIHdyaXRhYmxlIGJ1dCBoYWQgYSBwZW5kaW5nIGNsb3NlLCB0cmlnZ2VyIGFuIGVtcHR5IHNlbmRcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUgJiYgdGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmlnZ2VyaW5nIGVtcHR5IHNlbmQgdG8gYXBwZW5kIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3Qgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFSZXEpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5kYXRhUmVzLCAnLmRhdGFSZXEgYW5kIC5kYXRhUmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IG92ZXJsYXAgZnJvbSBjbGllbnRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDQwMCk7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNCaW5hcnkgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiID09PSByZXEuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgaWYgKGlzQmluYXJ5ICYmIHRoaXMucHJvdG9jb2wgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUmVxID0gcmVxO1xuICAgICAgICB0aGlzLmRhdGFSZXMgPSByZXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBpc0JpbmFyeSA/IEJ1ZmZlci5jb25jYXQoW10pIDogXCJcIjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgb25EYXRhKTtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbkVuZCk7XG4gICAgICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVJlcSA9IHRoaXMuZGF0YVJlcyA9IGNodW5rcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3QgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRGF0YSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudExlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIGNodW5rcyA9IEJ1ZmZlci5jb25jYXQoW2NodW5rcywgZGF0YV0pO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBjaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCA+IHRoaXMubWF4SHR0cEJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDQxMykuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGNodW5rcyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIC8vIHRleHQvaHRtbCBpcyByZXF1aXJlZCBpbnN0ZWFkIG9mIHRleHQvcGxhaW4gdG8gYXZvaWQgYW5cbiAgICAgICAgICAgICAgICAvLyB1bndhbnRlZCBkb3dubG9hZCBkaWFsb2cgb24gY2VydGFpbiB1c2VyLWFnZW50cyAoR0gtNDMpXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IFwiMlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB0aGlzLmhlYWRlcnMocmVxLCBoZWFkZXJzKSk7XG4gICAgICAgICAgICByZXMuZW5kKFwib2tcIik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5vbihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICBpZiAoIWlzQmluYXJ5KVxuICAgICAgICAgICAgcmVxLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgcmVxLm9uKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICByZXEub24oXCJlbmRcIiwgb25FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGluY29taW5nIGRhdGEgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gZW5jb2RlZCBwYXlsb2FkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGRlYnVnKCdyZWNlaXZlZCBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAocGFja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHhociBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvbkNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gY2xvc2UgcGVuZGluZyBwb2xsIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25DbG9zZSgpO1xuICAgIH1cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJhcHBlbmRpbmcgY2xvc2UgcGFja2V0IHRvIHBheWxvYWRcIik7XG4gICAgICAgICAgICBwYWNrZXRzLnB1c2goeyB0eXBlOiBcImNsb3NlXCIgfSk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb1dyaXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzID0gcGFja2V0cy5zb21lKChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0Lm9wdGlvbnMgJiYgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YSwgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIGRvV3JpdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGFzIHJlc3BvbnNlIHRvIHBvbGwgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVidWcoJ3dyaXRpbmcgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCBvcHRpb25zLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSB3cml0ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IFVURi04IGlzIHJlcXVpcmVkIGZvciBwYWdlcyBub3Qgc2VydmVkIHVuZGVyIHV0ZlxuICAgICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGlzU3RyaW5nXG4gICAgICAgICAgICA/IFwidGV4dC9wbGFpbjsgY2hhcnNldD1VVEYtOFwiXG4gICAgICAgICAgICA6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZCgyMDAsIHRoaXMuaGVhZGVycyh0aGlzLnJlcSwgaGVhZGVycykpO1xuICAgICAgICAgICAgdGhpcy5yZXMuZW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmh0dHBDb21wcmVzc2lvbiB8fCAhb3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBpc1N0cmluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCB0aGlzLmh0dHBDb21wcmVzc2lvbi50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHRoaXMucmVxKS5lbmNvZGluZ3MoW1wiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUVuY29kaW5nXCJdID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHJlc3NlcyBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb21wcmVzcyhkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgZGVidWcoXCJjb21wcmVzc2luZ1wiKTtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBsZXQgbnJlYWQgPSAwO1xuICAgICAgICBjb21wcmVzc2lvbk1ldGhvZHNbZW5jb2RpbmddKHRoaXMuaHR0cENvbXByZXNzaW9uKVxuICAgICAgICAgICAgLm9uKFwiZXJyb3JcIiwgY2FsbGJhY2spXG4gICAgICAgICAgICAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZW5kKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIGxldCBjbG9zZVRpbWVvdXRUaW1lcjtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgZGVidWcoXCJhYm9ydGluZyBvbmdvaW5nIGRhdGEgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVJlcS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCB3cml0YWJsZSAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcImNsb3NlXCIgfV0pO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzY2FyZGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkaXNjYXJkZWQgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBub3Qgd3JpdGFibGUgLSBidWZmZXJpbmcgb3JkZXJseSBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBvbkNsb3NlO1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KG9uQ2xvc2UsIHRoaXMuY2xvc2VUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlYWRlcnMgZm9yIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyAtIGV4dHJhIGhlYWRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGhlYWRlcnMocmVxLCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgLy8gcHJldmVudCBYU1Mgd2FybmluZ3Mgb24gSUVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYXJuQm9vc3Qvc29ja2V0LmlvL3B1bGwvMTMzM1xuICAgICAgICBjb25zdCB1YSA9IHJlcS5oZWFkZXJzW1widXNlci1hZ2VudFwiXTtcbiAgICAgICAgaWYgKHVhICYmICh+dWEuaW5kZXhPZihcIjtNU0lFXCIpIHx8IH51YS5pbmRleE9mKFwiVHJpZGVudC9cIikpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1YU1MtUHJvdGVjdGlvblwiXSA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnNbXCJjYWNoZS1jb250cm9sXCJdID0gXCJuby1zdG9yZVwiO1xuICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGhlYWRlcnMsIHJlcSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZyA9IFBvbGxpbmc7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2xsaW5nIiwidHJhbnNwb3J0XzEiLCJyZXF1aXJlIiwiemxpYl8xIiwiYWNjZXB0cyIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb21wcmVzc2lvbk1ldGhvZHMiLCJnemlwIiwiY3JlYXRlR3ppcCIsImRlZmxhdGUiLCJjcmVhdGVEZWZsYXRlIiwiVHJhbnNwb3J0IiwiY29uc3RydWN0b3IiLCJyZXEiLCJjbG9zZVRpbWVvdXQiLCJuYW1lIiwib25SZXF1ZXN0IiwicmVzIiwibWV0aG9kIiwib25Qb2xsUmVxdWVzdCIsIm9uRGF0YVJlcXVlc3QiLCJ3cml0ZUhlYWQiLCJlbmQiLCJvbkVycm9yIiwib25DbG9zZSIsImNsZWFudXAiLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwid3JpdGFibGUiLCJlbWl0Iiwic2hvdWxkQ2xvc2UiLCJzZW5kIiwidHlwZSIsImRhdGFSZXEiLCJpc0JpbmFyeSIsImhlYWRlcnMiLCJwcm90b2NvbCIsImRhdGFSZXMiLCJjaHVua3MiLCJCdWZmZXIiLCJjb25jYXQiLCJvbkRhdGEiLCJvbkVuZCIsImRhdGEiLCJjb250ZW50TGVuZ3RoIiwibGVuZ3RoIiwiYnl0ZUxlbmd0aCIsIm1heEh0dHBCdWZmZXJTaXplIiwic2V0RW5jb2RpbmciLCJjYWxsYmFjayIsInBhY2tldCIsIm9uUGFja2V0IiwicGFyc2VyIiwiZGVjb2RlUGF5bG9hZCIsImZvckVhY2giLCJwYWNrZXRzIiwicHVzaCIsImRvV3JpdGUiLCJjb21wcmVzcyIsInNvbWUiLCJvcHRpb25zIiwid3JpdGUiLCJlbmNvZGVQYXlsb2FkIiwic3VwcG9ydHNCaW5hcnkiLCJpc1N0cmluZyIsImNvbnRlbnRUeXBlIiwicmVzcG9uZCIsImh0dHBDb21wcmVzc2lvbiIsImxlbiIsInRocmVzaG9sZCIsImVuY29kaW5nIiwiZW5jb2RpbmdzIiwiZXJyIiwiYnVmZmVycyIsIm5yZWFkIiwiY2h1bmsiLCJkb0Nsb3NlIiwiZm4iLCJjbG9zZVRpbWVvdXRUaW1lciIsImRlc3Ryb3kiLCJjbGVhclRpbWVvdXQiLCJkaXNjYXJkZWQiLCJzZXRUaW1lb3V0IiwidWEiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/websocket.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param {EngineRequest} req\n     */ constructor(req){\n        super(req);\n        this._doSend = (data)=>{\n            this.socket.send(data, this._onSent);\n        };\n        this._doSendLast = (data)=>{\n            this.socket.send(data, this._onSentLast);\n        };\n        this._onSent = (err)=>{\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            }\n        };\n        this._onSentLast = (err)=>{\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            } else {\n                this.emit(\"drain\");\n                this.writable = true;\n                this.emit(\"ready\");\n            }\n        };\n        this.socket = req.websocket;\n        this.socket.on(\"message\", (data, isBinary)=>{\n            const message = isBinary ? data : data.toString();\n            debug('received \"%s\"', message);\n            super.onData(message);\n        });\n        this.socket.once(\"close\", this.onClose.bind(this));\n        this.socket.on(\"error\", this.onError.bind(this));\n        this.writable = true;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */ get handlesUpgrades() {\n        return true;\n    }\n    send(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            if (this._canSendPreEncodedFrame(packet)) {\n                // the WebSocket frame was computed with WebSocket.Sender.frame()\n                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n                this.socket._sender.sendFrame(// @ts-ignore\n                packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);\n            } else {\n                this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);\n            }\n        }\n    }\n    /**\n     * Whether the encoding of the WebSocket frame can be skipped.\n     * @param packet\n     * @private\n     */ _canSendPreEncodedFrame(packet) {\n        var _a, _b, _c;\n        return !this.perMessageDeflate && typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === \"function\" && // @ts-ignore\n        ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined;\n    }\n    doClose(fn) {\n        debug(\"closing\");\n        this.socket.close();\n        fn && fn();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1FLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsTUFBTUwsa0JBQWtCQyxZQUFZSyxTQUFTO0lBQ3pDOzs7O0tBSUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUNDO1lBQ1osSUFBSSxDQUFDQyxNQUFNLENBQUNDLElBQUksQ0FBQ0YsTUFBTSxJQUFJLENBQUNHLE9BQU87UUFDdkM7UUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDSjtZQUNoQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDRixNQUFNLElBQUksQ0FBQ0ssV0FBVztRQUMzQztRQUNBLElBQUksQ0FBQ0YsT0FBTyxHQUFHLENBQUNHO1lBQ1osSUFBSUEsS0FBSztnQkFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxlQUFlRCxJQUFJRSxLQUFLO1lBQ3pDO1FBQ0o7UUFDQSxJQUFJLENBQUNILFdBQVcsR0FBRyxDQUFDQztZQUNoQixJQUFJQSxLQUFLO2dCQUNMLElBQUksQ0FBQ0MsT0FBTyxDQUFDLGVBQWVELElBQUlFLEtBQUs7WUFDekMsT0FDSztnQkFDRCxJQUFJLENBQUNDLElBQUksQ0FBQztnQkFDVixJQUFJLENBQUNDLFFBQVEsR0FBRztnQkFDaEIsSUFBSSxDQUFDRCxJQUFJLENBQUM7WUFDZDtRQUNKO1FBQ0EsSUFBSSxDQUFDUixNQUFNLEdBQUdILElBQUlhLFNBQVM7UUFDM0IsSUFBSSxDQUFDVixNQUFNLENBQUNXLEVBQUUsQ0FBQyxXQUFXLENBQUNaLE1BQU1hO1lBQzdCLE1BQU1DLFVBQVVELFdBQVdiLE9BQU9BLEtBQUtlLFFBQVE7WUFDL0NyQixNQUFNLGlCQUFpQm9CO1lBQ3ZCLEtBQUssQ0FBQ0UsT0FBT0Y7UUFDakI7UUFDQSxJQUFJLENBQUNiLE1BQU0sQ0FBQ2dCLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNoRCxJQUFJLENBQUNsQixNQUFNLENBQUNXLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQ0wsT0FBTyxDQUFDWSxJQUFJLENBQUMsSUFBSTtRQUM5QyxJQUFJLENBQUNULFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNVLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0FwQixLQUFLcUIsT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDYixRQUFRLEdBQUc7UUFDaEIsSUFBSyxJQUFJYyxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7WUFDekIsTUFBTUcsU0FBU0gsSUFBSSxNQUFNRCxRQUFRRSxNQUFNO1lBQ3ZDLElBQUksSUFBSSxDQUFDRyx1QkFBdUIsQ0FBQ0YsU0FBUztnQkFDdEMsaUVBQWlFO2dCQUNqRSx5RUFBeUU7Z0JBQ3pFLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQzRCLE9BQU8sQ0FBQ0MsU0FBUyxDQUM3QixhQUFhO2dCQUNiSixPQUFPSyxPQUFPLENBQUNDLGlCQUFpQixFQUFFTCxTQUFTLElBQUksQ0FBQ3RCLFdBQVcsR0FBRyxJQUFJLENBQUNGLE9BQU87WUFDOUUsT0FDSztnQkFDRCxJQUFJLENBQUM4QixNQUFNLENBQUNDLFlBQVksQ0FBQ1IsUUFBUSxJQUFJLENBQUNTLGNBQWMsRUFBRVIsU0FBUyxJQUFJLENBQUN2QixXQUFXLEdBQUcsSUFBSSxDQUFDTCxPQUFPO1lBQ2xHO1FBQ0o7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRDZCLHdCQUF3QkYsTUFBTSxFQUFFO1FBQzVCLElBQUlVLElBQUlDLElBQUlDO1FBQ1osT0FBUSxDQUFDLElBQUksQ0FBQ2xCLGlCQUFpQixJQUMzQixPQUFRLEVBQUNpQixLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDbkMsTUFBTSxNQUFNLFFBQVFtQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLE9BQU8sTUFBTSxRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLFNBQVMsTUFBTSxjQUV6SSxhQURhO1FBQ1osRUFBQ1EsS0FBS1osT0FBT0ssT0FBTyxNQUFNLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR04saUJBQWlCLE1BQU1PO0lBQzlGO0lBQ0FDLFFBQVFDLEVBQUUsRUFBRTtRQUNSL0MsTUFBTTtRQUNOLElBQUksQ0FBQ08sTUFBTSxDQUFDeUMsS0FBSztRQUNqQkQsTUFBTUE7SUFDVjtBQUNKO0FBQ0FyRCxpQkFBaUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3dlYnNvY2tldC5qcz80NzFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJTb2NrZXQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp3c1wiKTtcbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IHRyYW5zcG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmdpbmVSZXF1ZXN0fSByZXFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy5fZG9TZW5kID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSwgdGhpcy5fb25TZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZG9TZW5kTGFzdCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEsIHRoaXMuX29uU2VudExhc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vblNlbnQgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwid3JpdGUgZXJyb3JcIiwgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25TZW50TGFzdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ3cml0ZSBlcnJvclwiLCBlcnIuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0ID0gcmVxLndlYnNvY2tldDtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJtZXNzYWdlXCIsIChkYXRhLCBpc0JpbmFyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlYnVnKCdyZWNlaXZlZCBcIiVzXCInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHN1cGVyLm9uRGF0YShtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZXJyb3JcIiwgdGhpcy5vbkVycm9yLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIndlYnNvY2tldFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZlcnRpc2UgdXBncmFkZSBzdXBwb3J0LlxuICAgICAqL1xuICAgIGdldCBoYW5kbGVzVXBncmFkZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XG4gICAgICAgICAgICBjb25zdCBpc0xhc3QgPSBpICsgMSA9PT0gcGFja2V0cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FuU2VuZFByZUVuY29kZWRGcmFtZShwYWNrZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIFdlYlNvY2tldCBmcmFtZSB3YXMgY29tcHV0ZWQgd2l0aCBXZWJTb2NrZXQuU2VuZGVyLmZyYW1lKClcbiAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzYxNyNpc3N1ZWNvbW1lbnQtMjgzMDAyNDY5XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuX3NlbmRlci5zZW5kRnJhbWUoXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHBhY2tldC5vcHRpb25zLndzUHJlRW5jb2RlZEZyYW1lLCBpc0xhc3QgPyB0aGlzLl9vblNlbnRMYXN0IDogdGhpcy5fb25TZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGlzTGFzdCA/IHRoaXMuX2RvU2VuZExhc3QgOiB0aGlzLl9kb1NlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGVuY29kaW5nIG9mIHRoZSBXZWJTb2NrZXQgZnJhbWUgY2FuIGJlIHNraXBwZWQuXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhblNlbmRQcmVFbmNvZGVkRnJhbWUocGFja2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKCF0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgICAgICB0eXBlb2YgKChfYiA9IChfYSA9IHRoaXMuc29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3NlbmRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlbmRGcmFtZSkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgKChfYyA9IHBhY2tldC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mud3NQcmVFbmNvZGVkRnJhbWUpICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICB9XG59XG5leHBvcnRzLldlYlNvY2tldCA9IFdlYlNvY2tldDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldlYlNvY2tldCIsInRyYW5zcG9ydF8xIiwicmVxdWlyZSIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJUcmFuc3BvcnQiLCJjb25zdHJ1Y3RvciIsInJlcSIsIl9kb1NlbmQiLCJkYXRhIiwic29ja2V0Iiwic2VuZCIsIl9vblNlbnQiLCJfZG9TZW5kTGFzdCIsIl9vblNlbnRMYXN0IiwiZXJyIiwib25FcnJvciIsInN0YWNrIiwiZW1pdCIsIndyaXRhYmxlIiwid2Vic29ja2V0Iiwib24iLCJpc0JpbmFyeSIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsIm9uRGF0YSIsIm9uY2UiLCJvbkNsb3NlIiwiYmluZCIsInBlck1lc3NhZ2VEZWZsYXRlIiwibmFtZSIsImhhbmRsZXNVcGdyYWRlcyIsInBhY2tldHMiLCJpIiwibGVuZ3RoIiwicGFja2V0IiwiaXNMYXN0IiwiX2NhblNlbmRQcmVFbmNvZGVkRnJhbWUiLCJfc2VuZGVyIiwic2VuZEZyYW1lIiwib3B0aW9ucyIsIndzUHJlRW5jb2RlZEZyYW1lIiwicGFyc2VyIiwiZW5jb2RlUGFja2V0Iiwic3VwcG9ydHNCaW5hcnkiLCJfYSIsIl9iIiwiX2MiLCJ1bmRlZmluZWQiLCJkb0Nsb3NlIiwiZm4iLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/webtransport.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/webtransport.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebTransport = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine:webtransport\");\n/**\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API\n */ class WebTransport extends transport_1.Transport {\n    constructor(session, stream, reader){\n        super({\n            _query: {\n                EIO: \"4\"\n            }\n        });\n        this.session = session;\n        const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();\n        transformStream.readable.pipeTo(stream.writable).catch(()=>{\n            debug(\"the stream was closed\");\n        });\n        this.writer = transformStream.writable.getWriter();\n        (async ()=>{\n            try {\n                while(true){\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        debug(\"session is closed\");\n                        break;\n                    }\n                    debug(\"received chunk: %o\", value);\n                    this.onPacket(value);\n                }\n            } catch (e) {\n                debug(\"error while reading: %s\", e.message);\n            }\n        })();\n        session.closed.then(()=>this.onClose());\n        this.writable = true;\n    }\n    get name() {\n        return \"webtransport\";\n    }\n    async send(packets) {\n        this.writable = false;\n        try {\n            for(let i = 0; i < packets.length; i++){\n                const packet = packets[i];\n                await this.writer.write(packet);\n            }\n        } catch (e) {\n            debug(\"error while writing: %s\", e.message);\n        }\n        this.emit(\"drain\");\n        this.writable = true;\n        this.emit(\"ready\");\n    }\n    doClose(fn) {\n        debug(\"closing WebTransport session\");\n        this.session.close();\n        fn && fn();\n    }\n}\nexports.WebTransport = WebTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1FLHFCQUFxQkYsbUJBQU9BLENBQUMsa0ZBQWtCO0FBQ3JELE1BQU1HLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDbkM7O0NBRUMsR0FDRCxNQUFNTixxQkFBcUJDLFlBQVlNLFNBQVM7SUFDNUNDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLENBQUU7UUFDakMsS0FBSyxDQUFDO1lBQUVDLFFBQVE7Z0JBQUVDLEtBQUs7WUFBSTtRQUFFO1FBQzdCLElBQUksQ0FBQ0osT0FBTyxHQUFHQTtRQUNmLE1BQU1LLGtCQUFrQixDQUFDLEdBQUdWLG1CQUFtQlcseUJBQXlCO1FBQ3hFRCxnQkFBZ0JFLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDUCxPQUFPUSxRQUFRLEVBQUVDLEtBQUssQ0FBQztZQUNuRGQsTUFBTTtRQUNWO1FBQ0EsSUFBSSxDQUFDZSxNQUFNLEdBQUdOLGdCQUFnQkksUUFBUSxDQUFDRyxTQUFTO1FBQy9DO1lBQ0csSUFBSTtnQkFDQSxNQUFPLEtBQU07b0JBQ1QsTUFBTSxFQUFFdEIsS0FBSyxFQUFFdUIsSUFBSSxFQUFFLEdBQUcsTUFBTVgsT0FBT1ksSUFBSTtvQkFDekMsSUFBSUQsTUFBTTt3QkFDTmpCLE1BQU07d0JBQ047b0JBQ0o7b0JBQ0FBLE1BQU0sc0JBQXNCTjtvQkFDNUIsSUFBSSxDQUFDeUIsUUFBUSxDQUFDekI7Z0JBQ2xCO1lBQ0osRUFDQSxPQUFPMEIsR0FBRztnQkFDTnBCLE1BQU0sMkJBQTJCb0IsRUFBRUMsT0FBTztZQUM5QztRQUNKO1FBQ0FqQixRQUFRa0IsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBTSxJQUFJLENBQUNDLE9BQU87UUFDdEMsSUFBSSxDQUFDWCxRQUFRLEdBQUc7SUFDcEI7SUFDQSxJQUFJWSxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0EsTUFBTUMsS0FBS0MsT0FBTyxFQUFFO1FBQ2hCLElBQUksQ0FBQ2QsUUFBUSxHQUFHO1FBQ2hCLElBQUk7WUFDQSxJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSUQsUUFBUUUsTUFBTSxFQUFFRCxJQUFLO2dCQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7Z0JBQ3pCLE1BQU0sSUFBSSxDQUFDYixNQUFNLENBQUNnQixLQUFLLENBQUNEO1lBQzVCO1FBQ0osRUFDQSxPQUFPVixHQUFHO1lBQ05wQixNQUFNLDJCQUEyQm9CLEVBQUVDLE9BQU87UUFDOUM7UUFDQSxJQUFJLENBQUNXLElBQUksQ0FBQztRQUNWLElBQUksQ0FBQ25CLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNtQixJQUFJLENBQUM7SUFDZDtJQUNBQyxRQUFRQyxFQUFFLEVBQUU7UUFDUmxDLE1BQU07UUFDTixJQUFJLENBQUNJLE9BQU8sQ0FBQytCLEtBQUs7UUFDbEJELE1BQU1BO0lBQ1Y7QUFDSjtBQUNBekMsb0JBQW9CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy93ZWJ0cmFuc3BvcnQuanM/NzQxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGVuZ2luZV9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp3ZWJ0cmFuc3BvcnRcIik7XG4vKipcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlRyYW5zcG9ydF9BUElcbiAqL1xuY2xhc3MgV2ViVHJhbnNwb3J0IGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBzdHJlYW0sIHJlYWRlcikge1xuICAgICAgICBzdXBlcih7IF9xdWVyeTogeyBFSU86IFwiNFwiIH0gfSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmVhbSA9ICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSkoKTtcbiAgICAgICAgdHJhbnNmb3JtU3RyZWFtLnJlYWRhYmxlLnBpcGVUbyhzdHJlYW0ud3JpdGFibGUpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwidGhlIHN0cmVhbSB3YXMgY2xvc2VkXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB0cmFuc2Zvcm1TdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlc3Npb24gaXMgY2xvc2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZWNlaXZlZCBjaHVuazogJW9cIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFja2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgcmVhZGluZzogJXNcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgc2Vzc2lvbi5jbG9zZWQudGhlbigoKSA9PiB0aGlzLm9uQ2xvc2UoKSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2VidHJhbnNwb3J0XCI7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgd3JpdGluZzogJXNcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgIH1cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZyBXZWJUcmFuc3BvcnQgc2Vzc2lvblwiKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIGZuICYmIGZuKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJUcmFuc3BvcnQgPSBXZWJUcmFuc3BvcnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJXZWJUcmFuc3BvcnQiLCJ0cmFuc3BvcnRfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwiZW5naW5lX2lvX3BhcnNlcl8xIiwiZGVidWciLCJkZWZhdWx0IiwiVHJhbnNwb3J0IiwiY29uc3RydWN0b3IiLCJzZXNzaW9uIiwic3RyZWFtIiwicmVhZGVyIiwiX3F1ZXJ5IiwiRUlPIiwidHJhbnNmb3JtU3RyZWFtIiwiY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSIsInJlYWRhYmxlIiwicGlwZVRvIiwid3JpdGFibGUiLCJjYXRjaCIsIndyaXRlciIsImdldFdyaXRlciIsImRvbmUiLCJyZWFkIiwib25QYWNrZXQiLCJlIiwibWVzc2FnZSIsImNsb3NlZCIsInRoZW4iLCJvbkNsb3NlIiwibmFtZSIsInNlbmQiLCJwYWNrZXRzIiwiaSIsImxlbmd0aCIsInBhY2tldCIsIndyaXRlIiwiZW1pdCIsImRvQ2xvc2UiLCJmbiIsImNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/webtransport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/userver.js":
/*!*************************************************!*\
  !*** ./node_modules/engine.io/build/userver.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uServer = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/engine.io/build/server.js\");\nconst transports_uws_1 = __webpack_require__(/*! ./transports-uws */ \"(rsc)/./node_modules/engine.io/build/transports-uws/index.js\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\n/**\n * An Engine.IO server based on the `uWebSockets.js` package.\n */ // TODO export it into its own package\nclass uServer extends server_1.BaseServer {\n    init() {}\n    cleanup() {}\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */ prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        req.url = req.getUrl();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value)=>{\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n        };\n        res.onAborted(()=>{\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a µWebSockets.js server\n     * @param app\n     * @param options\n     */ attach(app /* : TemplatedApp */ , options = {}) {\n        const path = this._computePath(options);\n        app.any(path, this.handleRequest.bind(this))//\n        .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: (ws)=>{\n                const transport = ws.getUserData().transport;\n                transport.socket = ws;\n                transport.writable = true;\n                transport.emit(\"ready\");\n            },\n            message: (ws, message, isBinary)=>{\n                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message)=>{\n                ws.getUserData().transport.onClose(code, message);\n            }\n        });\n    }\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            return callback();\n        }\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        super._applyMiddlewares(req, req.res, (err)=>{\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            req.res.writeHead();\n            callback(err);\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                // @ts-ignore\n                this.clients[req._query.sid].transport.onRequest(req);\n            } else {\n                const closeConnection = (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        req.res = res;\n        const callback = async (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    return res.close();\n                } else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    return res.close();\n                } else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    return res.close();\n                } else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client._maybeUpgrade(transport);\n                }\n            } else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            // calling writeStatus() triggers the flushing of any header added in a middleware\n            req.res.writeStatus(\"101 Switching Protocols\");\n            res.upgrade({\n                transport\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n        const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res){\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n        this.isAborted = false;\n    }\n    set statusCode(status) {\n        if (!status) {\n            return;\n        }\n        // FIXME: handle all status codes?\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    writeHead(status) {\n        this.statusCode = status;\n    }\n    setHeader(key, value) {\n        if (Array.isArray(value)) {\n            value.forEach((val)=>{\n                this.writeHeader(key, val);\n            });\n        } else {\n            this.writeHeader(key, value);\n        }\n    }\n    removeHeader() {\n    // FIXME: not implemented\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() {}\n    writeStatus(status) {\n        if (this.isAborted) return;\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n        return this;\n    }\n    writeHeader(key, value) {\n        if (this.isAborted) return;\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        } else {\n            this.headers.push([\n                key,\n                value\n            ]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value])=>{\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (this.isAborted) return;\n        this.res.cork(()=>{\n            if (!this.statusWritten) {\n                // status will be inferred as \"200 OK\"\n                this.writeBufferedHeaders();\n            }\n            this.res.end(data);\n        });\n    }\n    onData(fn) {\n        if (this.isAborted) return;\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        if (this.isAborted) return;\n        this.res.onAborted(()=>{\n            // Any attempt to use the UWS response object after abort will throw!\n            this.isAborted = true;\n            fn();\n        });\n    }\n    cork(fn) {\n        if (this.isAborted) return;\n        this.res.cork(fn);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3VzZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLFVBQVVDLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGdFQUFVO0FBQ25DLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsc0ZBQWtCO0FBQ25ELE1BQU1HLFFBQVEsQ0FBQyxHQUFHSixRQUFRSyxPQUFPLEVBQUU7QUFDbkM7O0NBRUMsR0FDRCxzQ0FBc0M7QUFDdEMsTUFBTU4sZ0JBQWdCRyxTQUFTSSxVQUFVO0lBQ3JDQyxPQUFPLENBQUU7SUFDVEMsVUFBVSxDQUFFO0lBQ1o7Ozs7S0FJQyxHQUNEQyxRQUFRQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUNkRCxJQUFJRSxNQUFNLEdBQUdGLElBQUlHLFNBQVMsR0FBR0MsV0FBVztRQUN4Q0osSUFBSUssR0FBRyxHQUFHTCxJQUFJTSxNQUFNO1FBQ3BCLE1BQU1DLFNBQVMsSUFBSUMsZ0JBQWdCUixJQUFJUyxRQUFRO1FBQy9DVCxJQUFJVSxNQUFNLEdBQUd6QixPQUFPMEIsV0FBVyxDQUFDSixPQUFPSyxPQUFPO1FBQzlDWixJQUFJYSxPQUFPLEdBQUcsQ0FBQztRQUNmYixJQUFJYyxPQUFPLENBQUMsQ0FBQ0MsS0FBSzNCO1lBQ2RZLElBQUlhLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHM0I7UUFDdkI7UUFDQVksSUFBSWdCLFVBQVUsR0FBRztZQUNiQyxlQUFlQyxPQUFPQyxJQUFJLENBQUNsQixJQUFJbUIsc0JBQXNCLElBQUlDLFFBQVE7UUFDckU7UUFDQXBCLElBQUlxQixTQUFTLENBQUM7WUFDVjVCLE1BQU07UUFDVjtJQUNKO0lBQ0E2QixnQkFBZ0JDLGFBQWEsRUFBRXhCLEdBQUcsRUFBRTtRQUNoQyxPQUFPLElBQUlQ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SSxDQUFDWCxTQUFTLEVBQ2Q7UUFDSixJQUFJLENBQUMzRixHQUFHLENBQUNxRyxJQUFJLENBQUNDO0lBQ2xCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC91c2VydmVyLmpzP2ViOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVTZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XG5jb25zdCB0cmFuc3BvcnRzX3V3c18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy11d3NcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnV3c1wiKTtcbi8qKlxuICogQW4gRW5naW5lLklPIHNlcnZlciBiYXNlZCBvbiB0aGUgYHVXZWJTb2NrZXRzLmpzYCBwYWNrYWdlLlxuICovXG4vLyBUT0RPIGV4cG9ydCBpdCBpbnRvIGl0cyBvd24gcGFja2FnZVxuY2xhc3MgdVNlcnZlciBleHRlbmRzIHNlcnZlcl8xLkJhc2VTZXJ2ZXIge1xuICAgIGluaXQoKSB7IH1cbiAgICBjbGVhbnVwKCkgeyB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSByZXF1ZXN0IGJ5IHByb2Nlc3NpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJlcGFyZShyZXEsIHJlcykge1xuICAgICAgICByZXEubWV0aG9kID0gcmVxLmdldE1ldGhvZCgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcS51cmwgPSByZXEuZ2V0VXJsKCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocmVxLmdldFF1ZXJ5KCkpO1xuICAgICAgICByZXEuX3F1ZXJ5ID0gT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtcy5lbnRyaWVzKCkpO1xuICAgICAgICByZXEuaGVhZGVycyA9IHt9O1xuICAgICAgICByZXEuZm9yRWFjaCgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVxLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBCdWZmZXIuZnJvbShyZXMuZ2V0UmVtb3RlQWRkcmVzc0FzVGV4dCgpKS50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgICAgICByZXMub25BYm9ydGVkKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVzcG9uc2UgaGFzIGJlZW4gYWJvcnRlZFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzX3V3c18xLmRlZmF1bHRbdHJhbnNwb3J0TmFtZV0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBlbmdpbmUgdG8gYSDCtVdlYlNvY2tldHMuanMgc2VydmVyXG4gICAgICogQHBhcmFtIGFwcFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXR0YWNoKGFwcCAvKiA6IFRlbXBsYXRlZEFwcCAqLywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLl9jb21wdXRlUGF0aChvcHRpb25zKTtcbiAgICAgICAgYXBwXG4gICAgICAgICAgICAuYW55KHBhdGgsIHRoaXMuaGFuZGxlUmVxdWVzdC5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC53cyhwYXRoLCB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbjogb3B0aW9ucy5jb21wcmVzc2lvbixcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0OiBvcHRpb25zLmlkbGVUaW1lb3V0LFxuICAgICAgICAgICAgbWF4QmFja3ByZXNzdXJlOiBvcHRpb25zLm1heEJhY2twcmVzc3VyZSxcbiAgICAgICAgICAgIG1heFBheWxvYWRMZW5ndGg6IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRoaXMuaGFuZGxlVXBncmFkZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb3BlbjogKHdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gd3MuZ2V0VXNlckRhdGEoKS50cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNvY2tldCA9IHdzO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiAod3MsIG1lc3NhZ2UsIGlzQmluYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgd3MuZ2V0VXNlckRhdGEoKS50cmFuc3BvcnQub25EYXRhKGlzQmluYXJ5ID8gbWVzc2FnZSA6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiAod3MsIGNvZGUsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB3cy5nZXRVc2VyRGF0YSgpLnRyYW5zcG9ydC5vbkNsb3NlKGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5taWRkbGV3YXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWRlZCB0byBidWZmZXIgaGVhZGVycyB1bnRpbCB0aGUgc3RhdHVzIGlzIGNvbXB1dGVkXG4gICAgICAgIHJlcS5yZXMgPSBuZXcgUmVzcG9uc2VXcmFwcGVyKHJlcyk7XG4gICAgICAgIHN1cGVyLl9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVxLnJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gc29tZSBtaWRkbGV3YXJlcyAobGlrZSBleHByZXNzLXNlc3Npb24pIHdhaXQgZm9yIHRoZSB3cml0ZUhlYWQoKSBjYWxsIHRvIGZsdXNoIHRoZWlyIGhlYWRlcnNcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL3Nlc3Npb24vYmxvYi8xMDEwZmFkYzJmMDcxZGRmMmFkZDk0MjM1ZDcyMjI0Y2Y2NTE1OWM2L2luZGV4LmpzI0wyMjAtTDI0NFxuICAgICAgICAgICAgcmVxLnJlcy53cml0ZUhlYWQoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZXF1ZXN0KHJlcywgcmVxKSB7XG4gICAgICAgIGRlYnVnKCdoYW5kbGluZyBcIiVzXCIgaHR0cCByZXF1ZXN0IFwiJXNcIicsIHJlcS5nZXRNZXRob2QoKSwgcmVxLmdldFVybCgpKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSwgcmVzKTtcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2VydmVyXzEuU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRSZXF1ZXN0KHJlcS5yZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxLl9xdWVyeS5zaWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNldHRpbmcgbmV3IHJlcXVlc3QgZm9yIGV4aXN0aW5nIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzW3JlcS5fcXVlcnkuc2lkXS50cmFuc3BvcnQub25SZXF1ZXN0KHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIGNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7IG5hbWU6IFwiTUlERExFV0FSRV9GQUlMVVJFXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVVcGdyYWRlKHJlcywgcmVxLCBjb250ZXh0KSB7XG4gICAgICAgIGRlYnVnKFwib24gdXBncmFkZVwiKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSwgcmVzKTtcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhc3luYyAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2VydmVyXzEuU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICBsZXQgdHJhbnNwb3J0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gdHJ5aW5nIHRvIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5fbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gYXdhaXQgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGxpbmcgd3JpdGVTdGF0dXMoKSB0cmlnZ2VycyB0aGUgZmx1c2hpbmcgb2YgYW55IGhlYWRlciBhZGRlZCBpbiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgIHJlcS5yZXMud3JpdGVTdGF0dXMoXCIxMDEgU3dpdGNoaW5nIFByb3RvY29sc1wiKTtcbiAgICAgICAgICAgIHJlcy51cGdyYWRlKHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICB9LCByZXEuZ2V0SGVhZGVyKFwic2VjLXdlYnNvY2tldC1rZXlcIiksIHJlcS5nZXRIZWFkZXIoXCJzZWMtd2Vic29ja2V0LXByb3RvY29sXCIpLCByZXEuZ2V0SGVhZGVyKFwic2VjLXdlYnNvY2tldC1leHRlbnNpb25zXCIpLCBjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlcnZlcl8xLlNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yQ29kZSA9PT0gc2VydmVyXzEuU2VydmVyLmVycm9ycy5GT1JCSURERU5cbiAgICAgICAgICAgID8gXCI0MDMgRm9yYmlkZGVuXCJcbiAgICAgICAgICAgIDogXCI0MDAgQmFkIFJlcXVlc3RcIjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dCAmJiBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICAgICAgPyBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICAgICAgOiBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgICAgICByZXMud3JpdGVTdGF0dXMoc3RhdHVzQ29kZSk7XG4gICAgICAgIHJlcy53cml0ZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIHJlcy5lbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbmV4cG9ydHMudVNlcnZlciA9IHVTZXJ2ZXI7XG5jbGFzcyBSZXNwb25zZVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlcykge1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy5zdGF0dXNXcml0dGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzQ29kZShzdGF0dXMpIHtcbiAgICAgICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRTogaGFuZGxlIGFsbCBzdGF0dXMgY29kZXM/XG4gICAgICAgIHRoaXMud3JpdGVTdGF0dXMoc3RhdHVzID09PSAyMDAgPyBcIjIwMCBPS1wiIDogXCIyMDQgTm8gQ29udGVudFwiKTtcbiAgICB9XG4gICAgd3JpdGVIZWFkKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgfVxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlSGVhZGVyKCkge1xuICAgICAgICAvLyBGSVhNRTogbm90IGltcGxlbWVudGVkXG4gICAgfVxuICAgIC8vIG5lZWRlZCBieSB2YXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL3ZhcnkvYmxvYi81ZDcyNWQwNTliMzg3MTAyNWNmNzUzZTlkZmEwODkyNGQwYmNmYThmL2luZGV4LmpzI0wxMzRcbiAgICBnZXRIZWFkZXIoKSB7IH1cbiAgICB3cml0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy53cml0ZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB0aGlzLnN0YXR1c1dyaXR0ZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyZWRIZWFkZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3cml0ZUhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJDb250ZW50LUxlbmd0aFwiKSB7XG4gICAgICAgICAgICAvLyB0aGUgY29udGVudCBsZW5ndGggaXMgYXV0b21hdGljYWxseSBhZGRlZCBieSB1V2ViU29ja2V0cy5qc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUJ1ZmZlcmVkSGVhZGVycygpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzLmNvcmsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c1dyaXR0ZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXMgd2lsbCBiZSBpbmZlcnJlZCBhcyBcIjIwMCBPS1wiXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcmVkSGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXMuZW5kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25EYXRhKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMub25EYXRhKGZuKTtcbiAgICB9XG4gICAgb25BYm9ydGVkKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMub25BYm9ydGVkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEFueSBhdHRlbXB0IHRvIHVzZSB0aGUgVVdTIHJlc3BvbnNlIG9iamVjdCBhZnRlciBhYm9ydCB3aWxsIHRocm93IVxuICAgICAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvcmsoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy5jb3JrKGZuKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1U2VydmVyIiwiZGVidWdfMSIsInJlcXVpcmUiLCJzZXJ2ZXJfMSIsInRyYW5zcG9ydHNfdXdzXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJCYXNlU2VydmVyIiwiaW5pdCIsImNsZWFudXAiLCJwcmVwYXJlIiwicmVxIiwicmVzIiwibWV0aG9kIiwiZ2V0TWV0aG9kIiwidG9VcHBlckNhc2UiLCJ1cmwiLCJnZXRVcmwiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJnZXRRdWVyeSIsIl9xdWVyeSIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImhlYWRlcnMiLCJmb3JFYWNoIiwia2V5IiwiY29ubmVjdGlvbiIsInJlbW90ZUFkZHJlc3MiLCJCdWZmZXIiLCJmcm9tIiwiZ2V0UmVtb3RlQWRkcmVzc0FzVGV4dCIsInRvU3RyaW5nIiwib25BYm9ydGVkIiwiY3JlYXRlVHJhbnNwb3J0IiwidHJhbnNwb3J0TmFtZSIsImF0dGFjaCIsImFwcCIsIm9wdGlvbnMiLCJwYXRoIiwiX2NvbXB1dGVQYXRoIiwiYW55IiwiaGFuZGxlUmVxdWVzdCIsImJpbmQiLCJ3cyIsImNvbXByZXNzaW9uIiwiaWRsZVRpbWVvdXQiLCJtYXhCYWNrcHJlc3N1cmUiLCJtYXhQYXlsb2FkTGVuZ3RoIiwib3B0cyIsIm1heEh0dHBCdWZmZXJTaXplIiwidXBncmFkZSIsImhhbmRsZVVwZ3JhZGUiLCJvcGVuIiwidHJhbnNwb3J0IiwiZ2V0VXNlckRhdGEiLCJzb2NrZXQiLCJ3cml0YWJsZSIsImVtaXQiLCJtZXNzYWdlIiwiaXNCaW5hcnkiLCJvbkRhdGEiLCJjbG9zZSIsImNvZGUiLCJvbkNsb3NlIiwiX2FwcGx5TWlkZGxld2FyZXMiLCJjYWxsYmFjayIsIm1pZGRsZXdhcmVzIiwibGVuZ3RoIiwiUmVzcG9uc2VXcmFwcGVyIiwiZXJyIiwid3JpdGVIZWFkIiwiZXJyb3JDb2RlIiwiZXJyb3JDb250ZXh0IiwidW5kZWZpbmVkIiwiU2VydmVyIiwiZXJyb3JNZXNzYWdlcyIsImNvbnRleHQiLCJhYm9ydFJlcXVlc3QiLCJzaWQiLCJjbGllbnRzIiwib25SZXF1ZXN0IiwiY2xvc2VDb25uZWN0aW9uIiwiaGFuZHNoYWtlIiwiZXJyb3JzIiwiQkFEX1JFUVVFU1QiLCJuYW1lIiwidmVyaWZ5IiwiaWQiLCJjbGllbnQiLCJ1cGdyYWRpbmciLCJ1cGdyYWRlZCIsIl9tYXliZVVwZ3JhZGUiLCJ3cml0ZVN0YXR1cyIsImdldEhlYWRlciIsInN0YXR1c0NvZGUiLCJGT1JCSURERU4iLCJ3cml0ZUhlYWRlciIsImVuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zdHJ1Y3RvciIsInN0YXR1c1dyaXR0ZW4iLCJpc0Fib3J0ZWQiLCJzdGF0dXMiLCJzZXRIZWFkZXIiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWwiLCJyZW1vdmVIZWFkZXIiLCJ3cml0ZUJ1ZmZlcmVkSGVhZGVycyIsInB1c2giLCJkYXRhIiwiY29yayIsImZuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/userver.js\n");

/***/ })

};
;