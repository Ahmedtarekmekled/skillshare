/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io-adapter";
exports.ids = ["vendor-chunks/socket.io-adapter"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/cluster-adapter.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __rest = this && this.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n    return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function(MessageType) {\n    MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n    MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n    MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n    MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n    MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n    MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n    MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n    MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n    MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n    return {\n        rooms: [\n            ...opts.rooms\n        ],\n        except: [\n            ...opts.except\n        ],\n        flags: opts.flags\n    };\n}\nfunction decodeOptions(opts) {\n    return {\n        rooms: new Set(opts.rooms),\n        except: new Set(opts.except),\n        flags: opts.flags\n    };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */ class ClusterAdapter extends in_memory_adapter_1.Adapter {\n    constructor(nsp){\n        super(nsp);\n        this.requests = new Map();\n        this.ackRequests = new Map();\n        this.uid = randomId();\n    }\n    /**\n     * Called when receiving a message from another member of the cluster.\n     *\n     * @param message\n     * @param offset\n     * @protected\n     */ onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch(message.type){\n            case MessageType.BROADCAST:\n                {\n                    const withAck = message.data.requestId !== undefined;\n                    if (withAck) {\n                        super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount)=>{\n                            debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n                            this.publishResponse(message.uid, {\n                                type: MessageType.BROADCAST_CLIENT_COUNT,\n                                data: {\n                                    requestId: message.data.requestId,\n                                    clientCount\n                                }\n                            });\n                        }, (arg)=>{\n                            debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n                            this.publishResponse(message.uid, {\n                                type: MessageType.BROADCAST_ACK,\n                                data: {\n                                    requestId: message.data.requestId,\n                                    packet: arg\n                                }\n                            });\n                        });\n                    } else {\n                        const packet = message.data.packet;\n                        const opts = decodeOptions(message.data.opts);\n                        this.addOffsetIfNecessary(packet, opts, offset);\n                        super.broadcast(packet, opts);\n                    }\n                    break;\n                }\n            case MessageType.SOCKETS_JOIN:\n                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.SOCKETS_LEAVE:\n                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.DISCONNECT_SOCKETS:\n                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n                break;\n            case MessageType.FETCH_SOCKETS:\n                {\n                    debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n                    super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets)=>{\n                        this.publishResponse(message.uid, {\n                            type: MessageType.FETCH_SOCKETS_RESPONSE,\n                            data: {\n                                requestId: message.data.requestId,\n                                sockets: localSockets.map((socket)=>{\n                                    // remove sessionStore from handshake, as it may contain circular references\n                                    const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [\n                                        \"sessionStore\"\n                                    ]);\n                                    return {\n                                        id: socket.id,\n                                        handshake,\n                                        rooms: [\n                                            ...socket.rooms\n                                        ],\n                                        data: socket.data\n                                    };\n                                })\n                            }\n                        });\n                    });\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT:\n                {\n                    const packet = message.data.packet;\n                    const withAck = message.data.requestId !== undefined;\n                    if (!withAck) {\n                        this.nsp._onServerSideEmit(packet);\n                        return;\n                    }\n                    let called = false;\n                    const callback = (arg)=>{\n                        // only one argument is expected\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n                            data: {\n                                requestId: message.data.requestId,\n                                packet: arg\n                            }\n                        });\n                    };\n                    this.nsp._onServerSideEmit([\n                        ...packet,\n                        callback\n                    ]);\n                    break;\n                }\n            // @ts-ignore\n            case MessageType.BROADCAST_CLIENT_COUNT:\n            // @ts-ignore\n            case MessageType.BROADCAST_ACK:\n            // @ts-ignore\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n            // @ts-ignore\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n                // always call the onMessage() method\n                this.onResponse(message);\n                break;\n            default:\n                debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n        }\n    }\n    /**\n     * Called when receiving a response from another member of the cluster.\n     *\n     * @param response\n     * @protected\n     */ onResponse(response) {\n        var _a, _b;\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch(response.type){\n            case MessageType.BROADCAST_CLIENT_COUNT:\n                {\n                    (_a = this.ackRequests.get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n                    break;\n                }\n            case MessageType.BROADCAST_ACK:\n                {\n                    (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n                    break;\n                }\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n                {\n                    const request = this.requests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.current++;\n                    response.data.sockets.forEach((socket)=>request.responses.push(socket));\n                    if (request.current === request.expected) {\n                        clearTimeout(request.timeout);\n                        request.resolve(request.responses);\n                        this.requests.delete(requestId);\n                    }\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                {\n                    const request = this.requests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.current++;\n                    request.responses.push(response.data.packet);\n                    if (request.current === request.expected) {\n                        clearTimeout(request.timeout);\n                        request.resolve(null, request.responses);\n                        this.requests.delete(requestId);\n                    }\n                    break;\n                }\n            default:\n                // @ts-ignore\n                debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n        }\n    }\n    async broadcast(packet, opts) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                const offset = await this.publishAndReturnOffset({\n                    type: MessageType.BROADCAST,\n                    data: {\n                        packet,\n                        opts: encodeOptions(opts)\n                    }\n                });\n                this.addOffsetIfNecessary(packet, opts, offset);\n            } catch (e) {\n                return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n            }\n        }\n        super.broadcast(packet, opts);\n    }\n    /**\n     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n     * reconnects after a temporary disconnection.\n     *\n     * @param packet\n     * @param opts\n     * @param offset\n     * @private\n     */ addOffsetIfNecessary(packet, opts, offset) {\n        var _a;\n        if (!this.nsp.server.opts.connectionStateRecovery) {\n            return;\n        }\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            packet.data.push(offset);\n        }\n    }\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        var _a;\n        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            const requestId = randomId();\n            this.ackRequests.set(requestId, {\n                clientCountCallback,\n                ack\n            });\n            this.publish({\n                type: MessageType.BROADCAST,\n                data: {\n                    packet,\n                    requestId,\n                    opts: encodeOptions(opts)\n                }\n            });\n            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n            // will simply clean up the ackRequests map after the given delay\n            setTimeout(()=>{\n                this.ackRequests.delete(requestId);\n            }, opts.flags.timeout);\n        }\n        super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n    }\n    async addSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_JOIN,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.addSockets(opts, rooms);\n    }\n    async delSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_LEAVE,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.delSockets(opts, rooms);\n    }\n    async disconnectSockets(opts, close) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.DISCONNECT_SOCKETS,\n                    data: {\n                        opts: encodeOptions(opts),\n                        close\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.disconnectSockets(opts, close);\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets(opts),\n            this.serverCount()\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const storedRequest = this.requests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n                    this.requests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                current: 0,\n                expected: expectedResponseCount,\n                responses: localSockets\n            };\n            this.requests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId\n                }\n            });\n        });\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet\n                }\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = await this.serverCount() - 1;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(()=>{\n            const storedRequest = this.requests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n                this.requests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            current: 0,\n            expected: expectedResponseCount,\n            responses: []\n        };\n        this.requests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet\n            }\n        });\n    }\n    publish(message) {\n        this.publishAndReturnOffset(message).catch((err)=>{\n            debug(\"[%s] error while publishing message: %s\", this.uid, err);\n        });\n    }\n    publishAndReturnOffset(message) {\n        message.uid = this.uid;\n        message.nsp = this.nsp.name;\n        return this.doPublish(message);\n    }\n    publishResponse(requesterUid, response) {\n        response.uid = this.uid;\n        response.nsp = this.nsp.name;\n        this.doPublishResponse(requesterUid, response).catch((err)=>{\n            debug(\"[%s] error while publishing response: %s\", this.uid, err);\n        });\n    }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n    constructor(nsp, opts){\n        super(nsp);\n        this.nodesMap = new Map(); // uid => timestamp of last message\n        this.customRequests = new Map();\n        this._opts = Object.assign({\n            heartbeatInterval: 5000,\n            heartbeatTimeout: 10000\n        }, opts);\n        this.cleanupTimer = setInterval(()=>{\n            const now = Date.now();\n            this.nodesMap.forEach((lastSeen, uid)=>{\n                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n                if (nodeSeemsDown) {\n                    debug(\"[%s] node %s seems down\", this.uid, uid);\n                    this.removeNode(uid);\n                }\n            });\n        }, 1000);\n    }\n    init() {\n        this.publish({\n            type: MessageType.INITIAL_HEARTBEAT\n        });\n    }\n    scheduleHeartbeat() {\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.refresh();\n        } else {\n            this.heartbeatTimer = setTimeout(()=>{\n                this.publish({\n                    type: MessageType.HEARTBEAT\n                });\n            }, this._opts.heartbeatInterval);\n        }\n    }\n    close() {\n        this.publish({\n            type: MessageType.ADAPTER_CLOSE\n        });\n        clearTimeout(this.heartbeatTimer);\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        if (message.uid && message.uid !== EMITTER_UID) {\n            // we track the UID of each sender, in order to know how many servers there are in the cluster\n            this.nodesMap.set(message.uid, Date.now());\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch(message.type){\n            case MessageType.INITIAL_HEARTBEAT:\n                this.publish({\n                    type: MessageType.HEARTBEAT\n                });\n                break;\n            case MessageType.HEARTBEAT:\n                break;\n            case MessageType.ADAPTER_CLOSE:\n                this.removeNode(message.uid);\n                break;\n            default:\n                super.onMessage(message, offset);\n        }\n    }\n    serverCount() {\n        return Promise.resolve(1 + this.nodesMap.size);\n    }\n    publish(message) {\n        this.scheduleHeartbeat();\n        return super.publish(message);\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet\n                }\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = this.nodesMap.size;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(()=>{\n            const storedRequest = this.customRequests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n                this.customRequests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            missingUids: new Set([\n                ...this.nodesMap.keys()\n            ]),\n            responses: []\n        };\n        this.customRequests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet\n            }\n        });\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets({\n                rooms: opts.rooms,\n                except: opts.except,\n                flags: {\n                    local: true\n                }\n            }),\n            this.serverCount()\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const storedRequest = this.customRequests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n                    this.customRequests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                missingUids: new Set([\n                    ...this.nodesMap.keys()\n                ]),\n                responses: localSockets\n            };\n            this.customRequests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId\n                }\n            });\n        });\n    }\n    onResponse(response) {\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch(response.type){\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n                {\n                    const request = this.customRequests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    response.data.sockets.forEach((socket)=>request.responses.push(socket));\n                    request.missingUids.delete(response.uid);\n                    if (request.missingUids.size === 0) {\n                        clearTimeout(request.timeout);\n                        request.resolve(request.responses);\n                        this.customRequests.delete(requestId);\n                    }\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                {\n                    const request = this.customRequests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.responses.push(response.data.packet);\n                    request.missingUids.delete(response.uid);\n                    if (request.missingUids.size === 0) {\n                        clearTimeout(request.timeout);\n                        request.resolve(null, request.responses);\n                        this.customRequests.delete(requestId);\n                    }\n                    break;\n                }\n            default:\n                super.onResponse(response);\n        }\n    }\n    removeNode(uid) {\n        this.customRequests.forEach((request, requestId)=>{\n            request.missingUids.delete(uid);\n            if (request.missingUids.size === 0) {\n                clearTimeout(request.timeout);\n                if (request.type === MessageType.FETCH_SOCKETS) {\n                    request.resolve(request.responses);\n                } else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n                    request.resolve(null, request.responses);\n                }\n                this.customRequests.delete(requestId);\n            }\n        });\n        this.nodesMap.delete(uid);\n    }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jbHVzdGVyLWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxTQUFTLElBQUssSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSyxTQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDaEQsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBQ0FFLDhDQUE2QztJQUFFVyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQ0FBbUMsR0FBR0Esc0JBQXNCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDMUYsTUFBTUssc0JBQXNCQyxtQkFBT0EsQ0FBQyw2RkFBcUI7QUFDekQsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMscUZBQU87QUFDL0IsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMs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Q0FBQ1QsU0FBU3JDLElBQUksQ0FBQ0ksTUFBTTtvQkFDM0NzQyxRQUFRMkQsV0FBVyxDQUFDbEQsTUFBTSxDQUFDZCxTQUFTNUMsR0FBRztvQkFDdkMsSUFBSWlELFFBQVEyRCxXQUFXLENBQUNELElBQUksS0FBSyxHQUFHO3dCQUNoQ3BELGFBQWFOLFFBQVFPLE9BQU87d0JBQzVCUCxRQUFRUSxPQUFPLENBQUMsTUFBTVIsUUFBUUcsU0FBUzt3QkFDdkMsSUFBSSxDQUFDbUMsY0FBYyxDQUFDN0IsTUFBTSxDQUFDbEQ7b0JBQy9CO29CQUNBO2dCQUNKO1lBQ0E7Z0JBQ0ksS0FBSyxDQUFDbUMsV0FBV0M7UUFDekI7SUFDSjtJQUNBc0QsV0FBV2xHLEdBQUcsRUFBRTtRQUNaLElBQUksQ0FBQ3VGLGNBQWMsQ0FBQ3BDLE9BQU8sQ0FBQyxDQUFDRixTQUFTekM7WUFDbEN5QyxRQUFRMkQsV0FBVyxDQUFDbEQsTUFBTSxDQUFDMUQ7WUFDM0IsSUFBSWlELFFBQVEyRCxXQUFXLENBQUNELElBQUksS0FBSyxHQUFHO2dCQUNoQ3BELGFBQWFOLFFBQVFPLE9BQU87Z0JBQzVCLElBQUlQLFFBQVE3QyxJQUFJLEtBQUs1QixZQUFZa0QsYUFBYSxFQUFFO29CQUM1Q3VCLFFBQVFRLE9BQU8sQ0FBQ1IsUUFBUUcsU0FBUztnQkFDckMsT0FDSyxJQUFJSCxRQUFRN0MsSUFBSSxLQUFLNUIsWUFBWThELGdCQUFnQixFQUFFO29CQUNwRFcsUUFBUVEsT0FBTyxDQUFDLE1BQU1SLFFBQVFHLFNBQVM7Z0JBQzNDO2dCQUNBLElBQUksQ0FBQ21DLGNBQWMsQ0FBQzdCLE1BQU0sQ0FBQ2xEO1lBQy9CO1FBQ0o7UUFDQSxJQUFJLENBQUM4RSxRQUFRLENBQUM1QixNQUFNLENBQUMxRDtJQUN6QjtBQUNKO0FBQ0E1QixtQ0FBbUMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY2x1c3Rlci1hZGFwdGVyLmpzP2FhMjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCA9IGV4cG9ydHMuQ2x1c3RlckFkYXB0ZXIgPSBleHBvcnRzLk1lc3NhZ2VUeXBlID0gdm9pZCAwO1xuY29uc3QgaW5fbWVtb3J5X2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL2luLW1lbW9yeS1hZGFwdGVyXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVidWcpKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBFTUlUVEVSX1VJRCA9IFwiZW1pdHRlclwiO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gNTAwMDtcbmZ1bmN0aW9uIHJhbmRvbUlkKCkge1xuICAgIHJldHVybiAoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDgpLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiSU5JVElBTF9IRUFSVEJFQVRcIl0gPSAxXSA9IFwiSU5JVElBTF9IRUFSVEJFQVRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkhFQVJUQkVBVFwiXSA9IDJdID0gXCJIRUFSVEJFQVRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkJST0FEQ0FTVFwiXSA9IDNdID0gXCJCUk9BRENBU1RcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNPQ0tFVFNfSk9JTlwiXSA9IDRdID0gXCJTT0NLRVRTX0pPSU5cIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNPQ0tFVFNfTEVBVkVcIl0gPSA1XSA9IFwiU09DS0VUU19MRUFWRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiRElTQ09OTkVDVF9TT0NLRVRTXCJdID0gNl0gPSBcIkRJU0NPTk5FQ1RfU09DS0VUU1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiRkVUQ0hfU09DS0VUU1wiXSA9IDddID0gXCJGRVRDSF9TT0NLRVRTXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJGRVRDSF9TT0NLRVRTX1JFU1BPTlNFXCJdID0gOF0gPSBcIkZFVENIX1NPQ0tFVFNfUkVTUE9OU0VcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNFUlZFUl9TSURFX0VNSVRcIl0gPSA5XSA9IFwiU0VSVkVSX1NJREVfRU1JVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRVwiXSA9IDEwXSA9IFwiU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQlJPQURDQVNUX0NMSUVOVF9DT1VOVFwiXSA9IDExXSA9IFwiQlJPQURDQVNUX0NMSUVOVF9DT1VOVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQlJPQURDQVNUX0FDS1wiXSA9IDEyXSA9IFwiQlJPQURDQVNUX0FDS1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQURBUFRFUl9DTE9TRVwiXSA9IDEzXSA9IFwiQURBUFRFUl9DTE9TRVwiO1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGVuY29kZU9wdGlvbnMob3B0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb21zOiBbLi4ub3B0cy5yb29tc10sXG4gICAgICAgIGV4Y2VwdDogWy4uLm9wdHMuZXhjZXB0XSxcbiAgICAgICAgZmxhZ3M6IG9wdHMuZmxhZ3MsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlY29kZU9wdGlvbnMob3B0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb21zOiBuZXcgU2V0KG9wdHMucm9vbXMpLFxuICAgICAgICBleGNlcHQ6IG5ldyBTZXQob3B0cy5leGNlcHQpLFxuICAgICAgICBmbGFnczogb3B0cy5mbGFncyxcbiAgICB9O1xufVxuLyoqXG4gKiBBIGNsdXN0ZXItcmVhZHkgYWRhcHRlci4gQW55IGV4dGVuZGluZyBjbGFzcyBtdXN0OlxuICpcbiAqIC0gaW1wbGVtZW50IHtAbGluayBDbHVzdGVyQWRhcHRlciNkb1B1Ymxpc2h9IGFuZCB7QGxpbmsgQ2x1c3RlckFkYXB0ZXIjZG9QdWJsaXNoUmVzcG9uc2V9XG4gKiAtIGNhbGwge0BsaW5rIENsdXN0ZXJBZGFwdGVyI29uTWVzc2FnZX0gYW5kIHtAbGluayBDbHVzdGVyQWRhcHRlciNvblJlc3BvbnNlfVxuICovXG5jbGFzcyBDbHVzdGVyQWRhcHRlciBleHRlbmRzIGluX21lbW9yeV9hZGFwdGVyXzEuQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IobnNwKSB7XG4gICAgICAgIHN1cGVyKG5zcCk7XG4gICAgICAgIHRoaXMucmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWNrUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudWlkID0gcmFuZG9tSWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcmVjZWl2aW5nIGEgbWVzc2FnZSBmcm9tIGFub3RoZXIgbWVtYmVyIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiWyVzXSBpZ25vcmUgbWVzc2FnZSBmcm9tIHNlbGZcIiwgdGhpcy51aWQpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiWyVzXSBuZXcgZXZlbnQgb2YgdHlwZSAlZCBmcm9tICVzXCIsIHRoaXMudWlkLCBtZXNzYWdlLnR5cGUsIG1lc3NhZ2UudWlkKTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEFjayA9IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAod2l0aEFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5icm9hZGNhc3RXaXRoQWNrKG1lc3NhZ2UuZGF0YS5wYWNrZXQsIGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCAoY2xpZW50Q291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSB3YWl0aW5nIGZvciAlZCBjbGllbnQgYWNrbm93bGVkZ2VtZW50c1wiLCB0aGlzLnVpZCwgY2xpZW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQ0xJRU5UX0NPVU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSByZWNlaXZlZCBhY2tub3dsZWRnZW1lbnQgd2l0aCB2YWx1ZSAlalwiLCB0aGlzLnVpZCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3BvbnNlKG1lc3NhZ2UudWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNUX0FDSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0OiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IG1lc3NhZ2UuZGF0YS5wYWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRPZmZzZXRJZk5lY2Vzc2FyeShwYWNrZXQsIG9wdHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU09DS0VUU19KT0lOOlxuICAgICAgICAgICAgICAgIHN1cGVyLmFkZFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIG1lc3NhZ2UuZGF0YS5yb29tcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNPQ0tFVFNfTEVBVkU6XG4gICAgICAgICAgICAgICAgc3VwZXIuZGVsU29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSwgbWVzc2FnZS5kYXRhLnJvb21zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRElTQ09OTkVDVF9TT0NLRVRTOlxuICAgICAgICAgICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RTb2NrZXRzKGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCBtZXNzYWdlLmRhdGEuY2xvc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTOiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIGNhbGxpbmcgZmV0Y2hTb2NrZXRzIHdpdGggb3B0cyAlalwiLCB0aGlzLnVpZCwgbWVzc2FnZS5kYXRhLm9wdHMpO1xuICAgICAgICAgICAgICAgIHN1cGVyXG4gICAgICAgICAgICAgICAgICAgIC5mZXRjaFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChsb2NhbFNvY2tldHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldHM6IGxvY2FsU29ja2V0cy5tYXAoKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2Vzc2lvblN0b3JlIGZyb20gaGFuZHNoYWtlLCBhcyBpdCBtYXkgY29udGFpbiBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gc29ja2V0LmhhbmRzaGFrZSwgeyBzZXNzaW9uU3RvcmUgfSA9IF9hLCBoYW5kc2hha2UgPSBfX3Jlc3QoX2EsIFtcInNlc3Npb25TdG9yZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc29ja2V0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXM6IFsuLi5zb2NrZXQucm9vbXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc29ja2V0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IG1lc3NhZ2UuZGF0YS5wYWNrZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEFjayA9IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uc3AuX29uU2VydmVyU2lkZUVtaXQocGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgb25lIGFyZ3VtZW50IGlzIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gY2FsbGluZyBhY2tub3dsZWRnZW1lbnQgd2l0aCAlalwiLCB0aGlzLnVpZCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldDogYXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm5zcC5fb25TZXJ2ZXJTaWRlRW1pdChbLi4ucGFja2V0LCBjYWxsYmFja10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQ0xJRU5UX0NPVU5UOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQUNLOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTX1JFU1BPTlNFOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFOlxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZGluZyBjbGFzc2VzIG1heSBub3QgbWFrZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gYSBDbHVzdGVyTWVzc2FnZSBhbmQgYSBDbHVzdGVyUmVzcG9uc2UgcGF5bG9hZCBhbmQgbWF5XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGNhbGwgdGhlIG9uTWVzc2FnZSgpIG1ldGhvZFxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHVua25vd24gbWVzc2FnZSB0eXBlOiAlc1wiLCB0aGlzLnVpZCwgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIGFub3RoZXIgbWVtYmVyIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UuZGF0YS5yZXF1ZXN0SWQ7XG4gICAgICAgIGRlYnVnKFwiWyVzXSByZWNlaXZlZCByZXNwb25zZSAlcyB0byByZXF1ZXN0ICVzXCIsIHRoaXMudWlkLCByZXNwb25zZS50eXBlLCByZXF1ZXN0SWQpO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUX0NMSUVOVF9DT1VOVDoge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYWNrUmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgLmdldChyZXF1ZXN0SWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpZW50Q291bnRDYWxsYmFjayhyZXNwb25zZS5kYXRhLmNsaWVudENvdW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUX0FDSzoge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuYWNrUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2socmVzcG9uc2UuZGF0YS5wYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTX1JFU1BPTlNFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5zb2NrZXRzLmZvckVhY2goKHNvY2tldCkgPT4gcmVxdWVzdC5yZXNwb25zZXMucHVzaChzb2NrZXQpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jdXJyZW50ID09PSByZXF1ZXN0LmV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY3VycmVudCsrO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VzLnB1c2gocmVzcG9uc2UuZGF0YS5wYWNrZXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmN1cnJlbnQgPT09IHJlcXVlc3QuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsLCByZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHVua25vd24gcmVzcG9uc2UgdHlwZTogJXNcIiwgdGhpcy51aWQsIHJlc3BvbnNlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkJST0FEQ0FTVCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9mZnNldElmTmVjZXNzYXJ5KHBhY2tldCwgb3B0cywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBicm9hZGNhc3RpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gb2Zmc2V0IGF0IHRoZSBlbmQgb2YgdGhlIGRhdGEgYXJyYXkgaW4gb3JkZXIgdG8gYWxsb3cgdGhlIGNsaWVudCB0byByZWNlaXZlIGFueSBtaXNzZWQgcGFja2V0cyB3aGVuIGl0XG4gICAgICogcmVjb25uZWN0cyBhZnRlciBhIHRlbXBvcmFyeSBkaXNjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkT2Zmc2V0SWZOZWNlc3NhcnkocGFja2V0LCBvcHRzLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMubnNwLnNlcnZlci5vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFdmVudFBhY2tldCA9IHBhY2tldC50eXBlID09PSAyO1xuICAgICAgICAvLyBwYWNrZXRzIHdpdGggYWNrbm93bGVkZ2VtZW50IGFyZSBub3Qgc3RvcmVkIGJlY2F1c2UgdGhlIGFja25vd2xlZGdlbWVudCBmdW5jdGlvbiBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbmRcbiAgICAgICAgLy8gcmVzdG9yZWQgb24gYW5vdGhlciBzZXJ2ZXIgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgY29uc3Qgd2l0aG91dEFja25vd2xlZGdlbWVudCA9IHBhY2tldC5pZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBub3RWb2xhdGlsZSA9ICgoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eudm9sYXRpbGUpID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0V2ZW50UGFja2V0ICYmIHdpdGhvdXRBY2tub3dsZWRnZW1lbnQgJiYgbm90Vm9sYXRpbGUpIHtcbiAgICAgICAgICAgIHBhY2tldC5kYXRhLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicm9hZGNhc3RXaXRoQWNrKHBhY2tldCwgb3B0cywgY2xpZW50Q291bnRDYWxsYmFjaywgYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICAgICAgdGhpcy5hY2tSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q291bnRDYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNULFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBubyB3YXkgdG8ga25vdyBhdCB0aGlzIGxldmVsIHdoZXRoZXIgdGhlIHNlcnZlciBoYXMgcmVjZWl2ZWQgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gZWFjaCBjbGllbnQsIHNvIHdlXG4gICAgICAgICAgICAvLyB3aWxsIHNpbXBseSBjbGVhbiB1cCB0aGUgYWNrUmVxdWVzdHMgbWFwIGFmdGVyIHRoZSBnaXZlbiBkZWxheVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2tSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH0sIG9wdHMuZmxhZ3MudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYnJvYWRjYXN0V2l0aEFjayhwYWNrZXQsIG9wdHMsIGNsaWVudENvdW50Q2FsbGJhY2ssIGFjayk7XG4gICAgfVxuICAgIGFzeW5jIGFkZFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNPQ0tFVFNfSk9JTixcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21zLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5hZGRTb2NrZXRzKG9wdHMsIHJvb21zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU09DS0VUU19MRUFWRSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21zLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZWxTb2NrZXRzKG9wdHMsIHJvb21zKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdFNvY2tldHMob3B0cywgY2xvc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkRJU0NPTk5FQ1RfU09DS0VUUyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNjb25uZWN0U29ja2V0cyhvcHRzLCBjbG9zZSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU29ja2V0cyhvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgW2xvY2FsU29ja2V0cywgc2VydmVyQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc3VwZXIuZmV0Y2hTb2NrZXRzKG9wdHMpLFxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb3VudCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gc2VydmVyQ291bnQgLSAxO1xuICAgICAgICBpZiAoKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbCkgfHwgZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFNvY2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG9ubHkgJHtzdG9yZWRSZXF1ZXN0LmN1cnJlbnR9IHJlc3BvbnNlcyByZWNlaXZlZCBvdXQgb2YgJHtzdG9yZWRSZXF1ZXN0LmV4cGVjdGVkfWApKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRzLmZsYWdzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRSZXNwb25zZUNvdW50LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlczogbG9jYWxTb2NrZXRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgc3RvcmVkUmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2VydmVyU2lkZUVtaXQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IHdpdGhBY2sgPSB0eXBlb2YgcGFja2V0W3BhY2tldC5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjayA9IHBhY2tldC5wb3AoKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gKGF3YWl0IHRoaXMuc2VydmVyQ291bnQoKSkgLSAxO1xuICAgICAgICBkZWJ1ZygnWyVzXSB3YWl0aW5nIGZvciAlZCByZXNwb25zZXMgdG8gXCJzZXJ2ZXJTaWRlRW1pdFwiIHJlcXVlc3QnLCB0aGlzLnVpZCwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkUmVzcG9uc2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNrKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYWNrKG5ldyBFcnJvcihgdGltZW91dCByZWFjaGVkOiBvbmx5ICR7c3RvcmVkUmVxdWVzdC5jdXJyZW50fSByZXNwb25zZXMgcmVjZWl2ZWQgb3V0IG9mICR7c3RvcmVkUmVxdWVzdC5leHBlY3RlZH1gKSwgc3RvcmVkUmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIERFRkFVTFRfVElNRU9VVCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgcmVzb2x2ZTogYWNrLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRSZXNwb25zZUNvdW50LFxuICAgICAgICAgICAgcmVzcG9uc2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdWJsaXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KG1lc3NhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHVibGlzaEFuZFJldHVybk9mZnNldChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UudWlkID0gdGhpcy51aWQ7XG4gICAgICAgIG1lc3NhZ2UubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9QdWJsaXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBwdWJsaXNoUmVzcG9uc2UocmVxdWVzdGVyVWlkLCByZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS51aWQgPSB0aGlzLnVpZDtcbiAgICAgICAgcmVzcG9uc2UubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgdGhpcy5kb1B1Ymxpc2hSZXNwb25zZShyZXF1ZXN0ZXJVaWQsIHJlc3BvbnNlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyByZXNwb25zZTogJXNcIiwgdGhpcy51aWQsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2x1c3RlckFkYXB0ZXIgPSBDbHVzdGVyQWRhcHRlcjtcbmNsYXNzIENsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCBleHRlbmRzIENsdXN0ZXJBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihuc3AsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobnNwKTtcbiAgICAgICAgdGhpcy5ub2Rlc01hcCA9IG5ldyBNYXAoKTsgLy8gdWlkID0+IHRpbWVzdGFtcCBvZiBsYXN0IG1lc3NhZ2VcbiAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaGVhcnRiZWF0SW50ZXJ2YWw6IDUwMDAsXG4gICAgICAgICAgICBoZWFydGJlYXRUaW1lb3V0OiAxMDAwMCxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNNYXAuZm9yRWFjaCgobGFzdFNlZW4sIHVpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTZWVtc0Rvd24gPSBub3cgLSBsYXN0U2VlbiA+IHRoaXMuX29wdHMuaGVhcnRiZWF0VGltZW91dDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVNlZW1zRG93bikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gbm9kZSAlcyBzZWVtcyBkb3duXCIsIHRoaXMudWlkLCB1aWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUodWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5JTklUSUFMX0hFQVJUQkVBVCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlSGVhcnRiZWF0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lci5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuSEVBUlRCRUFULFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5fb3B0cy5oZWFydGJlYXRJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5BREFQVEVSX0NMT1NFLFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTWVzc2FnZShtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiWyVzXSBpZ25vcmUgbWVzc2FnZSBmcm9tIHNlbGZcIiwgdGhpcy51aWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVpZCAmJiBtZXNzYWdlLnVpZCAhPT0gRU1JVFRFUl9VSUQpIHtcbiAgICAgICAgICAgIC8vIHdlIHRyYWNrIHRoZSBVSUQgb2YgZWFjaCBzZW5kZXIsIGluIG9yZGVyIHRvIGtub3cgaG93IG1hbnkgc2VydmVycyB0aGVyZSBhcmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgICAgIHRoaXMubm9kZXNNYXAuc2V0KG1lc3NhZ2UudWlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcIlslc10gbmV3IGV2ZW50IG9mIHR5cGUgJWQgZnJvbSAlc1wiLCB0aGlzLnVpZCwgbWVzc2FnZS50eXBlLCBtZXNzYWdlLnVpZCk7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLklOSVRJQUxfSEVBUlRCRUFUOlxuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkhFQVJUQkVBVCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSEVBUlRCRUFUOlxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQURBUFRFUl9DTE9TRTpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUobWVzc2FnZS51aWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdXBlci5vbk1lc3NhZ2UobWVzc2FnZSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXJ2ZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgxICsgdGhpcy5ub2Rlc01hcC5zaXplKTtcbiAgICB9XG4gICAgcHVibGlzaChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVIZWFydGJlYXQoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnB1Ymxpc2gobWVzc2FnZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlcnZlclNpZGVFbWl0KHBhY2tldCkge1xuICAgICAgICBjb25zdCB3aXRoQWNrID0gdHlwZW9mIHBhY2tldFtwYWNrZXQubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKCF3aXRoQWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2sgPSBwYWNrZXQucG9wKCk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA9IHRoaXMubm9kZXNNYXAuc2l6ZTtcbiAgICAgICAgZGVidWcoJ1slc10gd2FpdGluZyBmb3IgJWQgcmVzcG9uc2VzIHRvIFwic2VydmVyU2lkZUVtaXRcIiByZXF1ZXN0JywgdGhpcy51aWQsIGV4cGVjdGVkUmVzcG9uc2VDb3VudCk7XG4gICAgICAgIGlmIChleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHRoaXMuY3VzdG9tUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGFjayhuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogbWlzc2luZyAke3N0b3JlZFJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZX0gcmVzcG9uc2VzYCksIHN0b3JlZFJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgIHJlc29sdmU6IGFjayxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBtaXNzaW5nVWlkczogbmV3IFNldChbLi4udGhpcy5ub2Rlc01hcC5rZXlzKCldKSxcbiAgICAgICAgICAgIHJlc3BvbnNlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgc3RvcmVkUmVxdWVzdCk7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hTb2NrZXRzKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBbbG9jYWxTb2NrZXRzLCBzZXJ2ZXJDb3VudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzdXBlci5mZXRjaFNvY2tldHMoe1xuICAgICAgICAgICAgICAgIHJvb21zOiBvcHRzLnJvb21zLFxuICAgICAgICAgICAgICAgIGV4Y2VwdDogb3B0cy5leGNlcHQsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb3VudCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gc2VydmVyQ291bnQgLSAxO1xuICAgICAgICBpZiAoKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbCkgfHwgZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFNvY2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG1pc3NpbmcgJHtzdG9yZWRSZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemV9IHJlc3BvbnNlc2ApKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRzLmZsYWdzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgbWlzc2luZ1VpZHM6IG5ldyBTZXQoWy4uLnRoaXMubm9kZXNNYXAua2V5cygpXSksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzOiBsb2NhbFNvY2tldHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLmRhdGEucmVxdWVzdElkO1xuICAgICAgICBkZWJ1ZyhcIlslc10gcmVjZWl2ZWQgcmVzcG9uc2UgJXMgdG8gcmVxdWVzdCAlc1wiLCB0aGlzLnVpZCwgcmVzcG9uc2UudHlwZSwgcmVxdWVzdElkKTtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLnNvY2tldHMuZm9yRWFjaCgoc29ja2V0KSA9PiByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHNvY2tldCkpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QubWlzc2luZ1VpZHMuZGVsZXRlKHJlc3BvbnNlLnVpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlLmRhdGEucGFja2V0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm1pc3NpbmdVaWRzLmRlbGV0ZShyZXNwb25zZS51aWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsLCByZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdXBlci5vblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVOb2RlKHVpZCkge1xuICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmZvckVhY2goKHJlcXVlc3QsIHJlcXVlc3RJZCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5taXNzaW5nVWlkcy5kZWxldGUodWlkKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50eXBlID09PSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3QudHlwZSA9PT0gTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUobnVsbCwgcmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2Rlc01hcC5kZWxldGUodWlkKTtcbiAgICB9XG59XG5leHBvcnRzLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCA9IENsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdDtcbiJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0IiwiQ2x1c3RlckFkYXB0ZXIiLCJNZXNzYWdlVHlwZSIsImluX21lbW9yeV9hZGFwdGVyXzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsImNyeXB0b18xIiwiZGVidWciLCJFTUlUVEVSX1VJRCIsIkRFRkFVTFRfVElNRU9VVCIsInJhbmRvbUlkIiwicmFuZG9tQnl0ZXMiLCJ0b1N0cmluZyIsImVuY29kZU9wdGlvbnMiLCJvcHRzIiwicm9vbXMiLCJleGNlcHQiLCJmbGFncyIsImRlY29kZU9wdGlvbnMiLCJTZXQiLCJBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJuc3AiLCJyZXF1ZXN0cyIsIk1hcCIsImFja1JlcXVlc3RzIiwidWlkIiwib25NZXNzYWdlIiwibWVzc2FnZSIsIm9mZnNldCIsInR5cGUiLCJCUk9BRENBU1QiLCJ3aXRoQWNrIiwiZGF0YSIsInJlcXVlc3RJZCIsInVuZGVmaW5lZCIsImJyb2FkY2FzdFdpdGhBY2siLCJwYWNrZXQiLCJjbGllbnRDb3VudCIsInB1Ymxpc2hSZXNwb25zZSIsIkJST0FEQ0FTVF9DTElFTlRfQ09VTlQiLCJhcmciLCJCUk9BRENBU1RfQUNLIiwiYWRkT2Zmc2V0SWZOZWNlc3NhcnkiLCJicm9hZGNhc3QiLCJTT0NLRVRTX0pPSU4iLCJhZGRTb2NrZXRzIiwiU09DS0VUU19MRUFWRSIsImRlbFNvY2tldHMiLCJESVNDT05ORUNUX1NPQ0tFVFMiLCJkaXNjb25uZWN0U29ja2V0cyIsImNsb3NlIiwiRkVUQ0hfU09DS0VUUyIsImZldGNoU29ja2V0cyIsInRoZW4iLCJsb2NhbFNvY2tldHMiLCJGRVRDSF9TT0NLRVRTX1JFU1BPTlNFIiwic29ja2V0cyIsIm1hcCIsInNvY2tldCIsIl9hIiwiaGFuZHNoYWtlIiwic2Vzc2lvblN0b3JlIiwiaWQiLCJTRVJWRVJfU0lERV9FTUlUIiwiX29uU2VydmVyU2lkZUVtaXQiLCJjYWxsZWQiLCJjYWxsYmFjayIsIlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0UiLCJvblJlc3BvbnNlIiwicmVzcG9uc2UiLCJfYiIsImdldCIsImNsaWVudENvdW50Q2FsbGJhY2siLCJhY2siLCJyZXF1ZXN0IiwiY3VycmVudCIsImZvckVhY2giLCJyZXNwb25zZXMiLCJwdXNoIiwiZXhwZWN0ZWQiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwicmVzb2x2ZSIsImRlbGV0ZSIsIm9ubHlMb2NhbCIsImxvY2FsIiwicHVibGlzaEFuZFJldHVybk9mZnNldCIsInNlcnZlciIsImNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5IiwiaXNFdmVudFBhY2tldCIsIndpdGhvdXRBY2tub3dsZWRnZW1lbnQiLCJub3RWb2xhdGlsZSIsInZvbGF0aWxlIiwic2V0IiwicHVibGlzaCIsInNldFRpbWVvdXQiLCJzZXJ2ZXJDb3VudCIsIlByb21pc2UiLCJhbGwiLCJleHBlY3RlZFJlc3BvbnNlQ291bnQiLCJyZWplY3QiLCJzdG9yZWRSZXF1ZXN0IiwiRXJyb3IiLCJzZXJ2ZXJTaWRlRW1pdCIsInBvcCIsImNhdGNoIiwiZXJyIiwibmFtZSIsImRvUHVibGlzaCIsInJlcXVlc3RlclVpZCIsImRvUHVibGlzaFJlc3BvbnNlIiwibm9kZXNNYXAiLCJjdXN0b21SZXF1ZXN0cyIsIl9vcHRzIiwiYXNzaWduIiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJoZWFydGJlYXRUaW1lb3V0IiwiY2xlYW51cFRpbWVyIiwic2V0SW50ZXJ2YWwiLCJub3ciLCJEYXRlIiwibGFzdFNlZW4iLCJub2RlU2VlbXNEb3duIiwicmVtb3ZlTm9kZSIsImluaXQiLCJJTklUSUFMX0hFQVJUQkVBVCIsInNjaGVkdWxlSGVhcnRiZWF0IiwiaGVhcnRiZWF0VGltZXIiLCJyZWZyZXNoIiwiSEVBUlRCRUFUIiwiQURBUFRFUl9DTE9TRSIsImNsZWFySW50ZXJ2YWwiLCJzaXplIiwibWlzc2luZ1VpZHMiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js":
/*!**************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/contrib/yeast.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// imported from https://github.com/unshiftio/yeast\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.yeast = exports.decode = exports.encode = void 0;\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */ function encode(num) {\n    let encoded = \"\";\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    }while (num > 0);\n    return encoded;\n}\nexports.encode = encode;\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */ function decode(str) {\n    let decoded = 0;\n    for(i = 0; i < str.length; i++){\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\nexports.decode = decode;\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */ function yeast() {\n    const now = encode(+new Date());\n    if (now !== prev) return seed = 0, prev = now;\n    return now + \".\" + encode(seed++);\n}\nexports.yeast = yeast;\n//\n// Map each character to its index.\n//\nfor(; i < length; i++)map[alphabet[i]] = i;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jb250cmliL3llYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1EQUFtRDtBQUN0QztBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3ZELE1BQU1LLFdBQVcsbUVBQW1FQyxLQUFLLENBQUMsS0FBS0MsU0FBUyxJQUFJQyxNQUFNLENBQUM7QUFDbkgsSUFBSUMsT0FBTyxHQUFHQyxJQUFJLEdBQUdDO0FBQ3JCOzs7Ozs7Q0FNQyxHQUNELFNBQVNQLE9BQU9RLEdBQUc7SUFDZixJQUFJQyxVQUFVO0lBQ2QsR0FBRztRQUNDQSxVQUFVUixRQUFRLENBQUNPLE1BQU1MLE9BQU8sR0FBR007UUFDbkNELE1BQU1FLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUw7SUFDM0IsUUFBU0ssTUFBTSxHQUFHO0lBQ2xCLE9BQU9DO0FBQ1g7QUFDQWIsY0FBYyxHQUFHSTtBQUNqQjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxPQUFPYSxHQUFHO0lBQ2YsSUFBSUMsVUFBVTtJQUNkLElBQUtQLElBQUksR0FBR0EsSUFBSU0sSUFBSVQsTUFBTSxFQUFFRyxJQUFLO1FBQzdCTyxVQUFVQSxVQUFVVixTQUFTQyxHQUFHLENBQUNRLElBQUlFLE1BQU0sQ0FBQ1IsR0FBRztJQUNuRDtJQUNBLE9BQU9PO0FBQ1g7QUFDQWpCLGNBQWMsR0FBR0c7QUFDakI7Ozs7O0NBS0MsR0FDRCxTQUFTRDtJQUNMLE1BQU1pQixNQUFNZixPQUFPLENBQUMsSUFBSWdCO0lBQ3hCLElBQUlELFFBQVFSLE1BQ1IsT0FBTyxPQUFRLEdBQUtBLE9BQU9RO0lBQy9CLE9BQU9BLE1BQU0sTUFBTWYsT0FBT0s7QUFDOUI7QUFDQVQsYUFBYSxHQUFHRTtBQUNoQixFQUFFO0FBQ0YsbUNBQW1DO0FBQ25DLEVBQUU7QUFDRixNQUFPUSxJQUFJSCxRQUFRRyxJQUNmRixHQUFHLENBQUNILFFBQVEsQ0FBQ0ssRUFBRSxDQUFDLEdBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2NvbnRyaWIveWVhc3QuanM/OGQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91bnNoaWZ0aW8veWVhc3RcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy55ZWFzdCA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBhbHBoYWJldCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotX1wiLnNwbGl0KFwiXCIpLCBsZW5ndGggPSA2NCwgbWFwID0ge307XG5sZXQgc2VlZCA9IDAsIGkgPSAwLCBwcmV2O1xuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICAgIGxldCBlbmNvZGVkID0gXCJcIjtcbiAgICBkbyB7XG4gICAgICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgIHJldHVybiBlbmNvZGVkO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgbGV0IGRlY29kZWQgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgICBjb25zdCBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuICAgIGlmIChub3cgIT09IHByZXYpXG4gICAgICAgIHJldHVybiAoc2VlZCA9IDApLCAocHJldiA9IG5vdyk7XG4gICAgcmV0dXJuIG5vdyArIFwiLlwiICsgZW5jb2RlKHNlZWQrKyk7XG59XG5leHBvcnRzLnllYXN0ID0geWVhc3Q7XG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwieWVhc3QiLCJkZWNvZGUiLCJlbmNvZGUiLCJhbHBoYWJldCIsInNwbGl0IiwibGVuZ3RoIiwibWFwIiwic2VlZCIsImkiLCJwcmV2IiwibnVtIiwiZW5jb2RlZCIsIk1hdGgiLCJmbG9vciIsInN0ciIsImRlY29kZWQiLCJjaGFyQXQiLCJub3ciLCJEYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/in-memory-adapter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst yeast_1 = __webpack_require__(/*! ./contrib/yeast */ \"(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */ constructor(nsp){\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */ init() {}\n    /**\n     * To be overridden\n     */ close() {}\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */ serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */ addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms){\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */ del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */ delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)){\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */ broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket)=>{\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */ broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket)=>{\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */ sockets(rooms) {\n        const sids = new Set();\n        this.apply({\n            rooms\n        }, (socket)=>{\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */ socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */ fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket)=>{\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */ addSockets(opts, rooms) {\n        this.apply(opts, (socket)=>{\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */ delSockets(opts, rooms) {\n        this.apply(opts, (socket)=>{\n            rooms.forEach((room)=>socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(opts, close) {\n        this.apply(opts, (socket)=>{\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms){\n                if (!this.rooms.has(room)) continue;\n                for (const id of this.rooms.get(room)){\n                    if (ids.has(id) || except.has(id)) continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        } else {\n            for (const [id] of this.sids){\n                if (except.has(id)) continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket) callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms){\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid)=>exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */ persistSession(session) {}\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */ restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp){\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(()=>{\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId)=>{\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for(let i = this.packets.length - 1; i >= 0; i--){\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet)=>packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for(let i = index + 1; i < this.packets.length; i++){\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), {\n            missedPackets\n        }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now()\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room)=>opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room)=>!opts.except.has(room));\n    return included && notExcluded;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBO0FBQ0pDLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDckQsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMscUZBQWlCO0FBQ3pDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLDRDQUFJO0FBQzlCLE1BQU1HLHFCQUFxQixPQUFRLEVBQUNYLEtBQUtVLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVRSxNQUFNLE1BQU0sUUFBUVosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYSxLQUFLLE1BQU07QUFDcEssTUFBTVAsZ0JBQWdCQyxTQUFTTyxZQUFZO0lBQ3ZDOzs7O0tBSUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlEO1FBQ2hCLElBQUksQ0FBQ0UsT0FBTyxHQUFHSixJQUFJSyxNQUFNLENBQUNELE9BQU87SUFDckM7SUFDQTs7S0FFQyxHQUNERSxPQUFPLENBQUU7SUFDVDs7S0FFQyxHQUNEQyxRQUFRLENBQUU7SUFDVjs7OztLQUlDLEdBQ0RDLGNBQWM7UUFDVixPQUFPQyxRQUFRQyxPQUFPLENBQUM7SUFDM0I7SUFDQTs7Ozs7O0tBTUMsR0FDREMsT0FBT0MsRUFBRSxFQUFFWCxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDRSxJQUFJLENBQUNVLEdBQUcsQ0FBQ0QsS0FBSztZQUNwQixJQUFJLENBQUNULElBQUksQ0FBQ1cs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QUFDRztJQUNsRSxPQUFPa0csWUFBWUU7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvaW4tbWVtb3J5LWFkYXB0ZXIuanM/MDhjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2Vzc2lvbkF3YXJlQWRhcHRlciA9IGV4cG9ydHMuQWRhcHRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHllYXN0XzEgPSByZXF1aXJlKFwiLi9jb250cmliL3llYXN0XCIpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZShcIndzXCIpO1xuY29uc3QgY2FuUHJlQ29tcHV0ZUZyYW1lID0gdHlwZW9mICgoX2EgPSBXZWJTb2NrZXQgPT09IG51bGwgfHwgV2ViU29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBXZWJTb2NrZXQuU2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWUpID09PSBcImZ1bmN0aW9uXCI7XG5jbGFzcyBBZGFwdGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbi1tZW1vcnkgYWRhcHRlciBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMucm9vbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2lkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbnNwLnNlcnZlci5lbmNvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuXG4gICAgICovXG4gICAgaW5pdCgpIHsgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBTb2NrZXQuSU8gc2VydmVycyBpbiB0aGUgY2x1c3RlclxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNlcnZlckNvdW50KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc29ja2V0IHRvIGEgbGlzdCBvZiByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gIGlkICAgICAgdGhlIHNvY2tldCBpZFxuICAgICAqIEBwYXJhbSB7U2V0PFJvb20+fSByb29tcyAgIGEgc2V0IG9mIHJvb21zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGFkZEFsbChpZCwgcm9vbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zaWRzLnNldChpZCwgbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2Ygcm9vbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2lkcy5nZXQoaWQpLmFkZChyb29tKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5oYXMocm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zLnNldChyb29tLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNyZWF0ZS1yb29tXCIsIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmdldChyb29tKS5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5nZXQocm9vbSkuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJqb2luLXJvb21cIiwgcm9vbSwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzb2NrZXQgZnJvbSBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgICAgdGhlIHNvY2tldCBpZFxuICAgICAqIEBwYXJhbSB7Um9vbX0gICAgIHJvb20gICB0aGUgcm9vbSBuYW1lXG4gICAgICovXG4gICAgZGVsKGlkLCByb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zaWRzLmdldChpZCkuZGVsZXRlKHJvb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbChyb29tLCBpZCk7XG4gICAgfVxuICAgIF9kZWwocm9vbSwgaWQpIHtcbiAgICAgICAgY29uc3QgX3Jvb20gPSB0aGlzLnJvb21zLmdldChyb29tKTtcbiAgICAgICAgaWYgKF9yb29tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBfcm9vbS5kZWxldGUoaWQpO1xuICAgICAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJsZWF2ZS1yb29tXCIsIHJvb20sIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcm9vbS5zaXplID09PSAwICYmIHRoaXMucm9vbXMuZGVsZXRlKHJvb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVsZXRlLXJvb21cIiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGFsbCByb29tcyBpdCdzIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgdGhlIHNvY2tldCBpZFxuICAgICAqL1xuICAgIGRlbEFsbChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHRoaXMuc2lkcy5nZXQoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWwocm9vbSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lkcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgLSBgZmxhZ3NgIHtPYmplY3R9IGZsYWdzIGZvciB0aGlzIHBhY2tldFxuICAgICAqICAtIGBleGNlcHRgIHtBcnJheX0gc2lkcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZFxuICAgICAqICAtIGByb29tc2Age0FycmF5fSBsaXN0IG9mIHJvb21zIHRvIGJyb2FkY2FzdCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAgIHRoZSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgICAgIHRoZSBvcHRpb25zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICAgICAgICBjb25zdCBwYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzcyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5fZW5jb2RlKHBhY2tldCwgcGFja2V0T3B0cyk7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb2NrZXQubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBwYWNrZXRPcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBwYWNrZXQgYW5kIGV4cGVjdHMgbXVsdGlwbGUgYWNrbm93bGVkZ2VtZW50cy5cbiAgICAgKlxuICAgICAqIE9wdGlvbnM6XG4gICAgICogIC0gYGZsYWdzYCB7T2JqZWN0fSBmbGFncyBmb3IgdGhpcyBwYWNrZXRcbiAgICAgKiAgLSBgZXhjZXB0YCB7QXJyYXl9IHNpZHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgICAgKiAgLSBgcm9vbXNgIHtBcnJheX0gbGlzdCBvZiByb29tcyB0byBicm9hZGNhc3QgdG9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgICB0aGUgcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICAgICB0aGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjbGllbnRDb3VudENhbGxiYWNrIC0gdGhlIG51bWJlciBvZiBjbGllbnRzIHRoYXQgcmVjZWl2ZWQgdGhlIHBhY2tldFxuICAgICAqIEBwYXJhbSBhY2sgICAgICAgICAgICAgICAgIC0gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY2xpZW50IHJlc3BvbnNlXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYnJvYWRjYXN0V2l0aEFjayhwYWNrZXQsIG9wdHMsIGNsaWVudENvdW50Q2FsbGJhY2ssIGFjaykge1xuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IHBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgLy8gd2UgY2FuIHVzZSB0aGUgc2FtZSBpZCBmb3IgZWFjaCBwYWNrZXQsIHNpbmNlIHRoZSBfaWRzIGNvdW50ZXIgaXMgY29tbW9uIChubyBkdXBsaWNhdGUpXG4gICAgICAgIHBhY2tldC5pZCA9IHRoaXMubnNwLl9pZHMrKztcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLl9lbmNvZGUocGFja2V0LCBwYWNrZXRPcHRzKTtcbiAgICAgICAgbGV0IGNsaWVudENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAvLyB0cmFjayB0aGUgdG90YWwgbnVtYmVyIG9mIGFja25vd2xlZGdlbWVudHMgdGhhdCBhcmUgZXhwZWN0ZWRcbiAgICAgICAgICAgIGNsaWVudENvdW50Kys7XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBhY2sgY2FsbGJhY2sgZm9yIGVhY2ggY2xpZW50IHJlc3BvbnNlXG4gICAgICAgICAgICBzb2NrZXQuYWNrcy5zZXQocGFja2V0LmlkLCBhY2spO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb2NrZXQubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBwYWNrZXRPcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsaWVudENvdW50Q2FsbGJhY2soY2xpZW50Q291bnQpO1xuICAgIH1cbiAgICBfZW5jb2RlKHBhY2tldCwgcGFja2V0T3B0cykge1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgaWYgKGNhblByZUNvbXB1dGVGcmFtZSAmJlxuICAgICAgICAgICAgZW5jb2RlZFBhY2tldHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICB0eXBlb2YgZW5jb2RlZFBhY2tldHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFwiNFwiIGJlaW5nIHRoZSBcIm1lc3NhZ2VcIiBwYWNrZXQgdHlwZSBpbiB0aGUgRW5naW5lLklPIHByb3RvY29sXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20oXCI0XCIgKyBlbmNvZGVkUGFja2V0c1swXSk7XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzYxNyNpc3N1ZWNvbW1lbnQtMjgzMDAyNDY5XG4gICAgICAgICAgICBwYWNrZXRPcHRzLndzUHJlRW5jb2RlZEZyYW1lID0gV2ViU29ja2V0LlNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1hc2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wY29kZTogMSxcbiAgICAgICAgICAgICAgICBmaW46IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlZFBhY2tldHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIHNvY2tldHMgYnkgc2lkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZXQ8Um9vbT59IHJvb21zICAgdGhlIGV4cGxpY2l0IHNldCBvZiByb29tcyB0byBjaGVjay5cbiAgICAgKi9cbiAgICBzb2NrZXRzKHJvb21zKSB7XG4gICAgICAgIGNvbnN0IHNpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYXBwbHkoeyByb29tcyB9LCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzaWRzLmFkZChzb2NrZXQuaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiByb29tcyBhIGdpdmVuIHNvY2tldCBoYXMgam9pbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gaWQgICB0aGUgc29ja2V0IGlkXG4gICAgICovXG4gICAgc29ja2V0Um9vbXMoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lkcy5nZXQoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKG9wdHMpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNvY2tldHMucHVzaChzb2NrZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzb2NrZXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIHJvb21zIC0gdGhlIHJvb21zIHRvIGpvaW5cbiAgICAgKi9cbiAgICBhZGRTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmpvaW4ocm9vbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSByb29tcyAtIHRoZSByb29tcyB0byBsZWF2ZVxuICAgICAqL1xuICAgIGRlbFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICByb29tcy5mb3JFYWNoKChyb29tKSA9PiBzb2NrZXQubGVhdmUocm9vbSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKG9wdHMsIGNsb3NlKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoY2xvc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwbHkob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgcm9vbXMgPSBvcHRzLnJvb21zO1xuICAgICAgICBjb25zdCBleGNlcHQgPSB0aGlzLmNvbXB1dGVFeGNlcHRTaWRzKG9wdHMuZXhjZXB0KTtcbiAgICAgICAgaWYgKHJvb21zLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5oYXMocm9vbSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5yb29tcy5nZXQocm9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5oYXMoaWQpIHx8IGV4Y2VwdC5oYXMoaWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWRdIG9mIHRoaXMuc2lkcykge1xuICAgICAgICAgICAgICAgIGlmIChleGNlcHQuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUV4Y2VwdFNpZHMoZXhjZXB0Um9vbXMpIHtcbiAgICAgICAgY29uc3QgZXhjZXB0U2lkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGV4Y2VwdFJvb21zICYmIGV4Y2VwdFJvb21zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgZXhjZXB0Um9vbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb29tcy5oYXMocm9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb29tcy5nZXQocm9vbSkuZm9yRWFjaCgoc2lkKSA9PiBleGNlcHRTaWRzLmFkZChzaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4Y2VwdFNpZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBwYWNrZXQgdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIGluIHRoZSBjbHVzdGVyXG4gICAgICogQHBhcmFtIHBhY2tldCAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChwYWNrZXQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHNlcnZlclNpZGVFbWl0KCkgZnVuY3Rpb25hbGl0eVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY2xpZW50IHNlc3Npb24gaW4gb3JkZXIgdG8gcmVzdG9yZSBpdCB1cG9uIHJlY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBwZXJzaXN0U2Vzc2lvbihzZXNzaW9uKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBzZXNzaW9uIGFuZCBmaW5kIHRoZSBwYWNrZXRzIHRoYXQgd2VyZSBtaXNzZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgKiBAcGFyYW0gcGlkXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqL1xuICAgIHJlc3RvcmVTZXNzaW9uKHBpZCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG5jbGFzcyBTZXNzaW9uQXdhcmVBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IobnNwKSB7XG4gICAgICAgIHN1cGVyKG5zcCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhY2tldHMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb24gPVxuICAgICAgICAgICAgbnNwLnNlcnZlci5vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5Lm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbjtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBEYXRlLm5vdygpIC0gdGhpcy5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKHNlc3Npb24sIHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBzZXNzaW9uLmRpc2Nvbm5lY3RlZEF0IDwgdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IHRoaXMucGFja2V0c1tpXS5lbWl0dGVkQXQgPCB0aHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWNrZXRzLnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNjAgKiAxMDAwKTtcbiAgICAgICAgLy8gcHJldmVudHMgdGhlIHRpbWVyIGZyb20ga2VlcGluZyB0aGUgcHJvY2VzcyBhbGl2ZVxuICAgICAgICB0aW1lci51bnJlZigpO1xuICAgIH1cbiAgICBwZXJzaXN0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHNlc3Npb24uZGlzY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNlc3Npb25zLnNldChzZXNzaW9uLnBpZCwgc2Vzc2lvbik7XG4gICAgfVxuICAgIHJlc3RvcmVTZXNzaW9uKHBpZCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zLmdldChwaWQpO1xuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBzZXNzaW9uIG1heSBoYXZlIGV4cGlyZWRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBzZXNzaW9uLmRpc2Nvbm5lY3RlZEF0ICsgdGhpcy5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb24gPCBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgLy8gdGhlIHNlc3Npb24gaGFzIGV4cGlyZWRcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZGVsZXRlKHBpZCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFja2V0cy5maW5kSW5kZXgoKHBhY2tldCkgPT4gcGFja2V0LmlkID09PSBvZmZzZXQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IG1heSBiZSB0b28gb2xkXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaXNzZWRQYWNrZXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCB0aGlzLnBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHRoaXMucGFja2V0c1tpXTtcbiAgICAgICAgICAgIGlmIChzaG91bGRJbmNsdWRlUGFja2V0KHNlc3Npb24ucm9vbXMsIHBhY2tldC5vcHRzKSkge1xuICAgICAgICAgICAgICAgIG1pc3NlZFBhY2tldHMucHVzaChwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlc3Npb24pLCB7IG1pc3NlZFBhY2tldHMgfSkpO1xuICAgIH1cbiAgICBicm9hZGNhc3QocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaXNFdmVudFBhY2tldCA9IHBhY2tldC50eXBlID09PSAyO1xuICAgICAgICAvLyBwYWNrZXRzIHdpdGggYWNrbm93bGVkZ2VtZW50IGFyZSBub3Qgc3RvcmVkIGJlY2F1c2UgdGhlIGFja25vd2xlZGdlbWVudCBmdW5jdGlvbiBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbmRcbiAgICAgICAgLy8gcmVzdG9yZWQgb24gYW5vdGhlciBzZXJ2ZXIgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgY29uc3Qgd2l0aG91dEFja25vd2xlZGdlbWVudCA9IHBhY2tldC5pZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBub3RWb2xhdGlsZSA9ICgoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eudm9sYXRpbGUpID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0V2ZW50UGFja2V0ICYmIHdpdGhvdXRBY2tub3dsZWRnZW1lbnQgJiYgbm90Vm9sYXRpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gKDAsIHllYXN0XzEueWVhc3QpKCk7XG4gICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBkYXRhIGFycmF5LCBzbyB0aGUgY2xpZW50IGtub3dzIHRoZSBJRCBvZiB0aGUgbGFzdCBwYWNrZXQgaXQgaGFzXG4gICAgICAgICAgICAvLyBwcm9jZXNzZWQgKGFuZCB0aGUgZm9ybWF0IGlzIGJhY2t3YXJkLWNvbXBhdGlibGUpXG4gICAgICAgICAgICBwYWNrZXQuZGF0YS5wdXNoKGlkKTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tldC5kYXRhLFxuICAgICAgICAgICAgICAgIGVtaXR0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2Vzc2lvbkF3YXJlQWRhcHRlciA9IFNlc3Npb25Bd2FyZUFkYXB0ZXI7XG5mdW5jdGlvbiBzaG91bGRJbmNsdWRlUGFja2V0KHNlc3Npb25Sb29tcywgb3B0cykge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gb3B0cy5yb29tcy5zaXplID09PSAwIHx8IHNlc3Npb25Sb29tcy5zb21lKChyb29tKSA9PiBvcHRzLnJvb21zLmhhcyhyb29tKSk7XG4gICAgY29uc3Qgbm90RXhjbHVkZWQgPSBzZXNzaW9uUm9vbXMuZXZlcnkoKHJvb20pID0+ICFvcHRzLmV4Y2VwdC5oYXMocm9vbSkpO1xuICAgIHJldHVybiBpbmNsdWRlZCAmJiBub3RFeGNsdWRlZDtcbn1cbiJdLCJuYW1lcyI6WyJfYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2Vzc2lvbkF3YXJlQWRhcHRlciIsIkFkYXB0ZXIiLCJldmVudHNfMSIsInJlcXVpcmUiLCJ5ZWFzdF8xIiwiV2ViU29ja2V0IiwiY2FuUHJlQ29tcHV0ZUZyYW1lIiwiU2VuZGVyIiwiZnJhbWUiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm5zcCIsInJvb21zIiwiTWFwIiwic2lkcyIsImVuY29kZXIiLCJzZXJ2ZXIiLCJpbml0IiwiY2xvc2UiLCJzZXJ2ZXJDb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiYWRkQWxsIiwiaWQiLCJoYXMiLCJzZXQiLCJTZXQiLCJyb29tIiwiZ2V0IiwiYWRkIiwiZW1pdCIsImRlbCIsImRlbGV0ZSIsIl9kZWwiLCJfcm9vbSIsImRlbGV0ZWQiLCJzaXplIiwiZGVsQWxsIiwiYnJvYWRjYXN0IiwicGFja2V0Iiwib3B0cyIsImZsYWdzIiwicGFja2V0T3B0cyIsInByZUVuY29kZWQiLCJ2b2xhdGlsZSIsImNvbXByZXNzIiwibmFtZSIsImVuY29kZWRQYWNrZXRzIiwiX2VuY29kZSIsImFwcGx5Iiwic29ja2V0Iiwibm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMiLCJjbGllbnQiLCJ3cml0ZVRvRW5naW5lIiwiYnJvYWRjYXN0V2l0aEFjayIsImNsaWVudENvdW50Q2FsbGJhY2siLCJhY2siLCJfaWRzIiwiY2xpZW50Q291bnQiLCJhY2tzIiwiZW5jb2RlIiwibGVuZ3RoIiwiZGF0YSIsIkJ1ZmZlciIsImZyb20iLCJ3c1ByZUVuY29kZWRGcmFtZSIsInJlYWRPbmx5IiwibWFzayIsInJzdjEiLCJvcGNvZGUiLCJmaW4iLCJzb2NrZXRzIiwic29ja2V0Um9vbXMiLCJmZXRjaFNvY2tldHMiLCJwdXNoIiwiYWRkU29ja2V0cyIsImpvaW4iLCJkZWxTb2NrZXRzIiwiZm9yRWFjaCIsImxlYXZlIiwiZGlzY29ubmVjdFNvY2tldHMiLCJkaXNjb25uZWN0IiwiY2FsbGJhY2siLCJleGNlcHQiLCJjb21wdXRlRXhjZXB0U2lkcyIsImlkcyIsImV4Y2VwdFJvb21zIiwiZXhjZXB0U2lkcyIsInNpZCIsInNlcnZlclNpZGVFbWl0IiwiY29uc29sZSIsIndhcm4iLCJwZXJzaXN0U2Vzc2lvbiIsInNlc3Npb24iLCJyZXN0b3JlU2Vzc2lvbiIsInBpZCIsIm9mZnNldCIsInNlc3Npb25zIiwicGFja2V0cyIsIm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbiIsImNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5IiwidGltZXIiLCJzZXRJbnRlcnZhbCIsInRocmVzaG9sZCIsIkRhdGUiLCJub3ciLCJzZXNzaW9uSWQiLCJoYXNFeHBpcmVkIiwiZGlzY29ubmVjdGVkQXQiLCJpIiwiZW1pdHRlZEF0Iiwic3BsaWNlIiwidW5yZWYiLCJpbmRleCIsImZpbmRJbmRleCIsIm1pc3NlZFBhY2tldHMiLCJzaG91bGRJbmNsdWRlUGFja2V0IiwiYXNzaWduIiwiaXNFdmVudFBhY2tldCIsInR5cGUiLCJ3aXRob3V0QWNrbm93bGVkZ2VtZW50IiwidW5kZWZpbmVkIiwibm90Vm9sYXRpbGUiLCJ5ZWFzdCIsInNlc3Npb25Sb29tcyIsImluY2x1ZGVkIiwic29tZSIsIm5vdEV4Y2x1ZGVkIiwiZXZlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MessageType = exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.SessionAwareAdapter = exports.Adapter = void 0;\nvar in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nObject.defineProperty(exports, \"Adapter\", ({\n    enumerable: true,\n    get: function() {\n        return in_memory_adapter_1.Adapter;\n    }\n}));\nObject.defineProperty(exports, \"SessionAwareAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return in_memory_adapter_1.SessionAwareAdapter;\n    }\n}));\nvar cluster_adapter_1 = __webpack_require__(/*! ./cluster-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\");\nObject.defineProperty(exports, \"ClusterAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.ClusterAdapter;\n    }\n}));\nObject.defineProperty(exports, \"ClusterAdapterWithHeartbeat\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.ClusterAdapterWithHeartbeat;\n    }\n}));\nObject.defineProperty(exports, \"MessageType\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.MessageType;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1DQUFtQyxHQUFHQSxzQkFBc0IsR0FBR0EsMkJBQTJCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzFJLElBQUlPLHNCQUFzQkMsbUJBQU9BLENBQUMsNkZBQXFCO0FBQ3ZEViwyQ0FBMEM7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsb0JBQW9CRCxPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekhSLHVEQUFzRDtJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxvQkFBb0JGLG1CQUFtQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pKLElBQUlNLG9CQUFvQkgsbUJBQU9BLENBQUMseUZBQW1CO0FBQ25EVixrREFBaUQ7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msa0JBQWtCUCxjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcklOLCtEQUE4RDtJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxrQkFBa0JSLDJCQUEyQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9KTCwrQ0FBOEM7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msa0JBQWtCVCxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvaW5kZXguanM/MmU0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVR5cGUgPSBleHBvcnRzLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCA9IGV4cG9ydHMuQ2x1c3RlckFkYXB0ZXIgPSBleHBvcnRzLlNlc3Npb25Bd2FyZUFkYXB0ZXIgPSBleHBvcnRzLkFkYXB0ZXIgPSB2b2lkIDA7XG52YXIgaW5fbWVtb3J5X2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL2luLW1lbW9yeS1hZGFwdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRhcHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5fbWVtb3J5X2FkYXB0ZXJfMS5BZGFwdGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2Vzc2lvbkF3YXJlQWRhcHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5fbWVtb3J5X2FkYXB0ZXJfMS5TZXNzaW9uQXdhcmVBZGFwdGVyOyB9IH0pO1xudmFyIGNsdXN0ZXJfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vY2x1c3Rlci1hZGFwdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2x1c3RlckFkYXB0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfYWRhcHRlcl8xLkNsdXN0ZXJBZGFwdGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyX2FkYXB0ZXJfMS5DbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2x1c3Rlcl9hZGFwdGVyXzEuTWVzc2FnZVR5cGU7IH0gfSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNZXNzYWdlVHlwZSIsIkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCIsIkNsdXN0ZXJBZGFwdGVyIiwiU2Vzc2lvbkF3YXJlQWRhcHRlciIsIkFkYXB0ZXIiLCJpbl9tZW1vcnlfYWRhcHRlcl8xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJjbHVzdGVyX2FkYXB0ZXJfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/browser.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ exports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNCQUFzQixHQUV0Qjs7Q0FFQyxHQUVEQSxrQkFBa0IsR0FBR0M7QUFDckJELFlBQVksR0FBR0U7QUFDZkYsWUFBWSxHQUFHRztBQUNmSCxpQkFBaUIsR0FBR0k7QUFDcEJKLGVBQWUsR0FBR007QUFDbEJOLGVBQWUsR0FBRyxDQUFDO0lBQ2xCLElBQUlRLFNBQVM7SUFFYixPQUFPO1FBQ04sSUFBSSxDQUFDQSxRQUFRO1lBQ1pBLFNBQVM7WUFDVEMsUUFBUUMsSUFBSSxDQUFDO1FBQ2Q7SUFDRDtBQUNEO0FBRUE7O0NBRUMsR0FFRFYsY0FBYyxHQUFHO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0E7QUFFRDs7Ozs7O0NBTUMsR0FFRCxzQ0FBc0M7QUFDdEMsU0FBU0k7SUFDUiw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLGFBQWE7SUFDYixJQUFJLEtBQWdILEVBQUUsRUFFckg7SUFFRCxvREFBb0Q7SUFDcEQsSUFBSSxPQUFPWSxjQUFjLGVBQWVBLFVBQVVD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dkcsMkRBQTJEO1FBQzNELE9BQU80QztJQUNSLEVBQUUsT0FBT0wsT0FBTztJQUNmLFVBQVU7SUFDViwwQ0FBMEM7SUFDM0M7QUFDRDtBQUVBZCxPQUFPL0IsT0FBTyxHQUFHbUQsbUJBQU9BLENBQUMsMkZBQVluRDtBQUVyQyxNQUFNLEVBQUNvRCxVQUFVLEVBQUMsR0FBR3JCLE9BQU8vQixPQUFPO0FBRW5DOztDQUVDLEdBRURvRCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJO1FBQ0gsT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN2QixFQUFFLE9BQU9ULE9BQU87UUFDZixPQUFPLGlDQUFpQ0EsTUFBTVksT0FBTztJQUN0RDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGxzaGFyZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MmY1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImRlc3Ryb3kiLCJ3YXJuZWQiLCJjb25zb2xlIiwid2FybiIsImNvbG9ycyIsIndpbmRvdyIsInByb2Nlc3MiLCJ0eXBlIiwiX19ud2pzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJtYXRjaCIsIm0iLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsInBhcnNlSW50IiwiYXJncyIsIm5hbWVzcGFjZSIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImMiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJyZXBsYWNlIiwibG9nIiwiZGVidWciLCJuYW1lc3BhY2VzIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlcnJvciIsInIiLCJnZXRJdGVtIiwiZW52IiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJyZXF1aXJlIiwiZm9ybWF0dGVycyIsImoiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/common.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQ0E7OztDQUdDLEdBRUQsU0FBU0EsTUFBTUMsR0FBRztJQUNqQkMsWUFBWUMsS0FBSyxHQUFHRDtJQUNwQkEsWUFBWUUsT0FBTyxHQUFHRjtJQUN0QkEsWUFBWUcsTUFBTSxHQUFHQTtJQUNyQkgsWUFBWUksT0FBTyxHQUFHQTtJQUN0QkosWUFBWUssTUFBTSxHQUFHQTtJQUNyQkwsWUFBWU0sT0FBTyxHQUFHQTtJQUN0Qk4sWUFBWU8sUUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztJQUMvQlIsWUFBWVMsT0FBTyxHQUFHQTtJQUV0QkMsT0FBT0MsSUFBSSxDQUFDWixLQUFLYSxPQUFPLENBQUNDLENBQUFBO1FBQ3hCYixXQUFXLENBQUNhLElBQUksR0FBR2QsR0FBRyxDQUFDYyxJQUFJO0lBQzVCO0lBRUE7O0NBRUEsR0FFQWIsWUFBWWMsS0FBSyxHQUFHLEVBQUU7SUFDdEJkLFlBQVllLEtBQUssR0FBRyxFQUFFO0lBRXRCOzs7O0NBSUEsR0FDQWYsWUFBWWdCLFVBQVUsR0FBRyxDQUFDO0lBRTFCOzs7OztDQUtBLEdBQ0EsU0FBU0MsWUFBWUMsU0FBUztRQUM3QixJQUFJQyxPQUFPO1FBRVgsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVHLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsT0FBTyxDQUFFQSxRQUFRLEtBQUtBLE9BQVFELFVBQVVJLFVBQVUsQ0FBQ0Y7WUFDbkRELFFBQVEsR0FBRywyQkFBMkI7UUFDdkM7UUFFQSxPQUFPbkIsWUFBWXVCLE1BQU0sQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDTixRQUFRbkIsWUFBWXVCLE1BQU0sQ0FBQ0YsTUFBTSxDQUFDO0lBQ3RFO0lBQ0FyQixZQUFZaUIsV0FBVyxHQUFHQTtJQUUxQjs7Ozs7O0NBTUEsR0FDQSxTQUFTakIsWUFBWWtCLFNBQVM7UUFDN0Is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QUFHOEMsTUFBTWxFLFlBQVllLEtBQUssQ0FBQ00sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVllLEtBQUssQ0FBQ0ssRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLElBQUtyRCxJQUFJLEdBQUc4QyxNQUFNbEUsWUFBWWMsS0FBSyxDQUFDTyxNQUFNLEVBQUVELElBQUk4QyxLQUFLOUMsSUFBSztZQUN6RCxJQUFJcEIsWUFBWWMsS0FBSyxDQUFDTSxFQUFFLENBQUNzRCxJQUFJLENBQUNELE9BQU87Z0JBQ3BDLE9BQU87WUFDUjtRQUNEO1FBRUEsT0FBTztJQUNSO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU0YsWUFBWUksTUFBTTtRQUMxQixPQUFPQSxPQUFPQyxRQUFRLEdBQ3BCQyxTQUFTLENBQUMsR0FBR0YsT0FBT0MsUUFBUSxHQUFHdkQsTUFBTSxHQUFHLEdBQ3hDbUIsT0FBTyxDQUFDLFdBQVc7SUFDdEI7SUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTckMsT0FBT3lDLEdBQUc7UUFDbEIsSUFBSUEsZUFBZWtDLE9BQU87WUFDekIsT0FBT2xDLElBQUltQyxLQUFLLElBQUluQyxJQUFJb0MsT0FBTztRQUNoQztRQUNBLE9BQU9wQztJQUNSO0lBRUE7OztDQUdBLEdBQ0EsU0FBU25DO1FBQ1J3RSxRQUFRQyxJQUFJLENBQUM7SUFDZDtJQUVBbEYsWUFBWUssTUFBTSxDQUFDTCxZQUFZbUYsSUFBSTtJQUVuQyxPQUFPbkY7QUFDUjtBQUVBb0YsT0FBT0MsT0FBTyxHQUFHdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzP2E2MjMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6WyJzZXR1cCIsImVudiIsImNyZWF0ZURlYnVnIiwiZGVidWciLCJkZWZhdWx0IiwiY29lcmNlIiwiZGlzYWJsZSIsImVuYWJsZSIsImVuYWJsZWQiLCJodW1hbml6ZSIsInJlcXVpcmUiLCJkZXN0cm95IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJuYW1lcyIsInNraXBzIiwiZm9ybWF0dGVycyIsInNlbGVjdENvbG9yIiwibmFtZXNwYWNlIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29sb3JzIiwiTWF0aCIsImFicyIsInByZXZUaW1lIiwiZW5hYmxlT3ZlcnJpZGUiLCJuYW1lc3BhY2VzQ2FjaGUiLCJlbmFibGVkQ2FjaGUiLCJhcmdzIiwic2VsZiIsImN1cnIiLCJOdW1iZXIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsInVuc2hpZnQiLCJpbmRleCIsInJlcGxhY2UiLCJtYXRjaCIsImZvcm1hdCIsImZvcm1hdHRlciIsInZhbCIsImNhbGwiLCJzcGxpY2UiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJsb2ciLCJhcHBseSIsInVzZUNvbG9ycyIsImNvbG9yIiwiZXh0ZW5kIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwibmFtZXNwYWNlcyIsInNldCIsInYiLCJpbml0IiwiZGVsaW1pdGVyIiwibmV3RGVidWciLCJzYXZlIiwic3BsaXQiLCJsZW4iLCJwdXNoIiwiUmVnRXhwIiwic2xpY2UiLCJtYXAiLCJ0b05hbWVzcGFjZSIsImpvaW4iLCJuYW1lIiwidGVzdCIsInJlZ2V4cCIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiRXJyb3IiLCJzdGFjayIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImxvYWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FFRCxJQUFJLE9BQU9BLFlBQVksZUFBZUEsUUFBUUMsSUFBSSxLQUFLLGNBQWNELEtBQWUsS0FBSyxRQUFRQSxRQUFRRyxNQUFNLEVBQUU7SUFDaEhDLG9JQUF5QjtBQUMxQixPQUFPO0lBQ05BLDhIQUF5QjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsc2hhcmUtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz9jN2VjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJ0eXBlIiwiYnJvd3NlciIsIl9fbndqcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/node.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ const tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFckI7O0NBRUMsR0FFREUsWUFBWSxHQUFHQztBQUNmRCxXQUFXLEdBQUdFO0FBQ2RGLGtCQUFrQixHQUFHRztBQUNyQkgsWUFBWSxHQUFHSTtBQUNmSixZQUFZLEdBQUdLO0FBQ2ZMLGlCQUFpQixHQUFHTTtBQUNwQk4sZUFBZSxHQUFHRCxLQUFLUyxTQUFTLENBQy9CLEtBQU8sR0FDUDtBQUdEOztDQUVDLEdBRURSLGNBQWMsR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRW5DLElBQUk7SUFDSCwyR0FBMkc7SUFDM0csNkRBQTZEO0lBQzdELE1BQU1VLGdCQUFnQlosbUJBQU9BLENBQUM7SUFFOUIsSUFBSVksaUJBQWlCLENBQUNBLGNBQWNDLE1BQU0sSUFBSUQsYUFBWSxFQUFHRSxLQUFLLElBQUksR0FBRztRQUN4RVosY0FBYyxHQUFHO1lBQ2hCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZ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TUFBTTNDLFdBQVcsR0FBRyxDQUFDO0lBRXJCLE1BQU1FLE9BQU9ELE9BQU9DLElBQUksQ0FBQ2hCLFFBQVFjLFdBQVc7SUFDNUMsSUFBSyxJQUFJNEMsSUFBSSxHQUFHQSxJQUFJMUMsS0FBSzJDLE1BQU0sRUFBRUQsSUFBSztRQUNyQ0QsTUFBTTNDLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDMEMsRUFBRSxDQUFDLEdBQUcxRCxRQUFRYyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQztJQUMxRDtBQUNEO0FBRUFaLE9BQU85QyxPQUFPLEdBQUdGLG1CQUFPQSxDQUFDLDJGQUFZRTtBQUVyQyxNQUFNLEVBQUM0RCxVQUFVLEVBQUMsR0FBR2QsT0FBTzlDLE9BQU87QUFFbkM7O0NBRUMsR0FFRDRELFdBQVdDLENBQUMsR0FBRyxTQUFVQyxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVcsRUFDckM2QixLQUFLLENBQUMsTUFDTnFCLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSSxJQUNuQnRCLElBQUksQ0FBQztBQUNSO0FBRUE7O0NBRUMsR0FFRGdCLFdBQVdPLENBQUMsR0FBRyxTQUFVTCxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVc7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2lsbHNoYXJlLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcz80NTY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLmRlc3Ryb3kgPSB1dGlsLmRlcHJlY2F0ZShcblx0KCkgPT4ge30sXG5cdCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJ1xuKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbnRyeSB7XG5cdC8vIE9wdGlvbmFsIGRlcGVuZGVuY3kgKGFzIGluLCBkb2Vzbid0IG5lZWQgdG8gYmUgaW5zdGFsbGVkLCBOT1QgbGlrZSBvcHRpb25hbERlcGVuZGVuY2llcyBpbiBwYWNrYWdlLmpzb24pXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcblx0Y29uc3Qgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5cblx0aWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcblx0XHRleHBvcnRzLmNvbG9ycyA9IFtcblx0XHRcdDIwLFxuXHRcdFx0MjEsXG5cdFx0XHQyNixcblx0XHRcdDI3LFxuXHRcdFx0MzIsXG5cdFx0XHQzMyxcblx0XHRcdDM4LFxuXHRcdFx0MzksXG5cdFx0XHQ0MCxcblx0XHRcdDQxLFxuXHRcdFx0NDIsXG5cdFx0XHQ0Myxcblx0XHRcdDQ0LFxuXHRcdFx0NDUsXG5cdFx0XHQ1Nixcblx0XHRcdDU3LFxuXHRcdFx0NjIsXG5cdFx0XHQ2Myxcblx0XHRcdDY4LFxuXHRcdFx0NjksXG5cdFx0XHQ3NCxcblx0XHRcdDc1LFxuXHRcdFx0NzYsXG5cdFx0XHQ3Nyxcblx0XHRcdDc4LFxuXHRcdFx0NzksXG5cdFx0XHQ4MCxcblx0XHRcdDgxLFxuXHRcdFx0OTIsXG5cdFx0XHQ5Myxcblx0XHRcdDk4LFxuXHRcdFx0OTksXG5cdFx0XHQxMTIsXG5cdFx0XHQxMTMsXG5cdFx0XHQxMjgsXG5cdFx0XHQxMjksXG5cdFx0XHQxMzQsXG5cdFx0XHQxMzUsXG5cdFx0XHQxNDgsXG5cdFx0XHQxNDksXG5cdFx0XHQxNjAsXG5cdFx0XHQxNjEsXG5cdFx0XHQxNjIsXG5cdFx0XHQxNjMsXG5cdFx0XHQxNjQsXG5cdFx0XHQxNjUsXG5cdFx0XHQxNjYsXG5cdFx0XHQxNjcsXG5cdFx0XHQxNjgsXG5cdFx0XHQxNjksXG5cdFx0XHQxNzAsXG5cdFx0XHQxNzEsXG5cdFx0XHQxNzIsXG5cdFx0XHQxNzMsXG5cdFx0XHQxNzgsXG5cdFx0XHQxNzksXG5cdFx0XHQxODQsXG5cdFx0XHQxODUsXG5cdFx0XHQxOTYsXG5cdFx0XHQxOTcsXG5cdFx0XHQxOTgsXG5cdFx0XHQxOTksXG5cdFx0XHQyMDAsXG5cdFx0XHQyMDEsXG5cdFx0XHQyMDIsXG5cdFx0XHQyMDMsXG5cdFx0XHQyMDQsXG5cdFx0XHQyMDUsXG5cdFx0XHQyMDYsXG5cdFx0XHQyMDcsXG5cdFx0XHQyMDgsXG5cdFx0XHQyMDksXG5cdFx0XHQyMTQsXG5cdFx0XHQyMTUsXG5cdFx0XHQyMjAsXG5cdFx0XHQyMjFcblx0XHRdO1xuXHR9XG59IGNhdGNoIChlcnJvcikge1xuXHQvLyBTd2FsbG93IC0gd2Ugb25seSBjYXJlIGlmIGBzdXBwb3J0cy1jb2xvcmAgaXMgYXZhaWxhYmxlOyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUuXG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGtleSA9PiB7XG5cdHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcblx0Ly8gQ2FtZWwtY2FzZVxuXHRjb25zdCBwcm9wID0ga2V5XG5cdFx0LnN1YnN0cmluZyg2KVxuXHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0LnJlcGxhY2UoL18oW2Etel0pL2csIChfLCBrKSA9PiB7XG5cdFx0XHRyZXR1cm4gay50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXG5cdC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXHRsZXQgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcblx0aWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSBmYWxzZTtcblx0fSBlbHNlIGlmICh2YWwgPT09ICdudWxsJykge1xuXHRcdHZhbCA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gTnVtYmVyKHZhbCk7XG5cdH1cblxuXHRvYmpbcHJvcF0gPSB2YWw7XG5cdHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0cmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHMgP1xuXHRcdEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDpcblx0XHR0dHkuaXNhdHR5KHByb2Nlc3Muc3RkZXJyLmZkKTtcbn1cblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0Y29uc3Qge25hbWVzcGFjZTogbmFtZSwgdXNlQ29sb3JzfSA9IHRoaXM7XG5cblx0aWYgKHVzZUNvbG9ycykge1xuXHRcdGNvbnN0IGMgPSB0aGlzLmNvbG9yO1xuXHRcdGNvbnN0IGNvbG9yQ29kZSA9ICdcXHUwMDFCWzMnICsgKGMgPCA4ID8gYyA6ICc4OzU7JyArIGMpO1xuXHRcdGNvbnN0IHByZWZpeCA9IGAgICR7Y29sb3JDb2RlfTsxbSR7bmFtZX0gXFx1MDAxQlswbWA7XG5cblx0XHRhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG5cdFx0YXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMUJbMG0nKTtcblx0fSBlbHNlIHtcblx0XHRhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcblx0aWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblx0cmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgJztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdFdpdGhPcHRpb25zKClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoZXhwb3J0cy5pbnNwZWN0T3B0cywgLi4uYXJncykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG5cdFx0Ly8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cblx0XHRkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRyZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdChkZWJ1Zykge1xuXHRkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChzdHIgPT4gc3RyLnRyaW0oKSlcblx0XHQuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuIl0sIm5hbWVzIjpbInR0eSIsInJlcXVpcmUiLCJ1dGlsIiwiZXhwb3J0cyIsImluaXQiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJkZXN0cm95IiwiZGVwcmVjYXRlIiwiY29sb3JzIiwic3VwcG9ydHNDb2xvciIsInN0ZGVyciIsImxldmVsIiwiZXJyb3IiLCJpbnNwZWN0T3B0cyIsIk9iamVjdCIsImtleXMiLCJwcm9jZXNzIiwiZW52IiwiZmlsdGVyIiwia2V5IiwidGVzdCIsInJlZHVjZSIsIm9iaiIsInByb3AiLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJfIiwiayIsInRvVXBwZXJDYXNlIiwidmFsIiwiTnVtYmVyIiwiQm9vbGVhbiIsImlzYXR0eSIsImZkIiwiYXJncyIsIm5hbWVzcGFjZSIsIm5hbWUiLCJjIiwiY29sb3IiLCJjb2xvckNvZGUiLCJwcmVmaXgiLCJzcGxpdCIsImpvaW4iLCJwdXNoIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiZ2V0RGF0ZSIsImhpZGVEYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwid3JpdGUiLCJmb3JtYXRXaXRoT3B0aW9ucyIsIm5hbWVzcGFjZXMiLCJERUJVRyIsImRlYnVnIiwiaSIsImxlbmd0aCIsImZvcm1hdHRlcnMiLCJvIiwidiIsImluc3BlY3QiLCJtYXAiLCJzdHIiLCJ0cmltIiwiTyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js\n");

/***/ })

};
;